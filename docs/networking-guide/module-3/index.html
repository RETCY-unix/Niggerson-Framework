<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Module 3: Port Scanner Implementation - TCP scanning theory and C code implementations from basic to advanced stealth techniques.">
    <title>MODULE 3: PORT SCANNER IMPLEMENTATION | FIELD MANUAL</title>
    <link rel="stylesheet" href="../styles.css">
</head>

<body>
    <div class="classification-banner">
        UNCLASSIFIED // MODULE 3 // PORT SCANNER IMPLEMENTATION
    </div>

    <header class="site-header">
        <h1 class="site-title">Module 3</h1>
        <p class="site-subtitle">Port Scanner Implementation in C</p>
    </header>

    <nav class="nav-main">
        <ul class="nav-list">
            <li><a href="../index.html" class="nav-link">HOME</a></li>
            <li><a href="../module-1/index.html" class="nav-link">MODULE 1</a></li>
            <li><a href="../module-2/index.html" class="nav-link">MODULE 2</a></li>
            <li><a href="index.html" class="nav-link active">MODULE 3</a></li>
        </ul>
    </nav>

    <main class="container">
        <div class="content-wrapper">
            <nav class="breadcrumb">
                <a href="../index.html">Home</a>
                <span class="breadcrumb-separator">/</span>
                <span>Module 3: Port Scanner Implementation</span>
            </nav>

            <p class="section-marker">// TCP FLAG QUICK REVISION</p>
            <h1>TCP Handshake and Scan Theory</h1>

            <h2>TCP Flags Quick Reference</h2>

            <div class="diagram">
                TCP FLAG BITS:

                +-----+-----+-----+-----+-----+-----+
                | URG | ACK | PSH | RST | SYN | FIN |
                +-----+-----+-----+-----+-----+-----+
                32 16 8 4 2 1

                SYN = Synchronize sequence numbers (initiate connection)
                ACK = Acknowledge received data
                RST = Reset connection (abort)
                FIN = Finish (close connection gracefully)
                PSH = Push data immediately
                URG = Urgent data
            </div>

            <h2>Three-Way Handshake</h2>

            <div class="diagram">
                NORMAL TCP CONNECTION (3-Way Handshake):

                CLIENT SERVER
                | |
                | [1] SYN (SEQ=100) |
                | "I want to connect" |
                |------------------------------------------------->|
                | |
                | [2] SYN-ACK (SEQ=300, ACK=101) |
                | "OK, I acknowledge your SYN" |
                |<-------------------------------------------------| | | | [3] ACK (SEQ=101, ACK=301) |
                    | "Connection established" | |------------------------------------------------->|
                    | |
                    |============= CONNECTION OPEN ===================|
            </div>

            <h2>Port Scan Response Analysis</h2>

            <table>
                <thead>
                    <tr>
                        <th>We Send</th>
                        <th>Response</th>
                        <th>Port State</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>SYN</td>
                        <td>SYN-ACK</td>
                        <td>OPEN (service listening)</td>
                    </tr>
                    <tr>
                        <td>SYN</td>
                        <td>RST</td>
                        <td>CLOSED (no service)</td>
                    </tr>
                    <tr>
                        <td>SYN</td>
                        <td>Nothing</td>
                        <td>FILTERED (firewall)</td>
                    </tr>
                </tbody>
            </table>

            <!-- ============================================
                 SCANNER 1: BASIC
                 ============================================ -->
            <p class="section-marker">// IMPLEMENTATION 1: BASIC CONNECT SCAN</p>
            <h1>Scanner 1: TCP Connect Scan (Full Handshake)</h1>

            <p>
                This scanner uses the system's <code>connect()</code> call to complete the full
                three-way handshake. It is the simplest method but is easily detected because
                connections are fully established and logged.
            </p>

            <div class="diagram">
                CONNECT SCAN FLOW:

                SCANNER TARGET
                | |
                | SYN ------------------------------> |
                | <------------------------------ SYN-ACK (OPEN!) | ACK ------------------------------> |
                    | ========= FULL CONNECTION LOGGED ========= |
                    | RST ------------------------------> |

                    DETECTION LEVEL: HIGH (Connection fully logged)
                    PRIVILEGES: None required (uses system socket)
            </div>

            <div class="technical-block">
                <div class="technical-block-title">basic_scanner.c</div>
                <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;

int scan_port(const char *target_ip, int port) {
    int sock;
    struct sockaddr_in target;
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("Socket creation failed");
        return -1;
    }
    
    memset(&target, 0, sizeof(target));
    target.sin_family = AF_INET;
    target.sin_port = htons(port);
    target.sin_addr.s_addr = inet_addr(target_ip);
    
    if (connect(sock, (struct sockaddr *)&target, sizeof(target)) == 0) {
        close(sock);
        return 1;
    }
    
    close(sock);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        printf("Usage: %s &lt;target_ip&gt; &lt;start_port&gt; &lt;end_port&gt;\n", argv[0]);
        return 1;
    }
    
    const char *target = argv[1];
    int start_port = atoi(argv[2]);
    int end_port = atoi(argv[3]);
    
    printf("[*] BASIC TCP CONNECT SCANNER\n");
    printf("[*] Target: %s | Ports: %d-%d\n\n", target, start_port, end_port);
    
    for (int port = start_port; port <= end_port; port++) {
        if (scan_port(target, port) == 1) {
            printf("[+] Port %d: OPEN\n", port);
        }
    }
    
    printf("\n[*] Scan complete.\n");
    return 0;
}</code></pre>
            </div>

            <h3>Code Breakdown</h3>

            <div class="technical-block">
                <div class="technical-block-title">Header Files Explained</div>
                <table>
                    <tr>
                        <td><code>stdio.h</code></td>
                        <td>Standard I/O - provides printf() for output</td>
                    </tr>
                    <tr>
                        <td><code>stdlib.h</code></td>
                        <td>Standard library - provides atoi() to convert strings to integers</td>
                    </tr>
                    <tr>
                        <td><code>string.h</code></td>
                        <td>String functions - provides memset() to zero out memory</td>
                    </tr>
                    <tr>
                        <td><code>sys/socket.h</code></td>
                        <td>Socket API - provides socket() and connect() functions</td>
                    </tr>
                    <tr>
                        <td><code>arpa/inet.h</code></td>
                        <td>Internet operations - provides inet_addr() and htons()</td>
                    </tr>
                    <tr>
                        <td><code>unistd.h</code></td>
                        <td>POSIX API - provides close() to close sockets</td>
                    </tr>
                </table>
            </div>

            <div class="technical-block">
                <div class="technical-block-title">Key Functions Explained</div>
                <p><strong>socket(AF_INET, SOCK_STREAM, 0)</strong></p>
                <ul>
                    <li><code>AF_INET</code> = IPv4 address family</li>
                    <li><code>SOCK_STREAM</code> = TCP protocol (reliable, connection-oriented)</li>
                    <li><code>0</code> = Let the system choose the protocol (TCP for STREAM)</li>
                    <li>Returns a file descriptor (integer) representing the socket</li>
                </ul>

                <p><strong>htons(port)</strong></p>
                <ul>
                    <li>Host TO Network Short - converts port number to network byte order</li>
                    <li>Network byte order is big-endian (most significant byte first)</li>
                    <li>Required because different CPUs store bytes in different orders</li>
                </ul>

                <p><strong>inet_addr(ip_string)</strong></p>
                <ul>
                    <li>Converts IP address string "192.168.1.1" to 32-bit binary format</li>
                    <li>Returns the IP in network byte order</li>
                </ul>

                <p><strong>connect()</strong></p>
                <ul>
                    <li>Performs the full TCP 3-way handshake</li>
                    <li>Returns 0 on success (port OPEN)</li>
                    <li>Returns -1 on failure (port CLOSED or FILTERED)</li>
                </ul>
            </div>

            <p><strong>Compile:</strong> <code>gcc -o basic_scanner basic_scanner.c</code></p>
            <p><strong>Run:</strong> <code>./basic_scanner 192.168.1.1 1 100</code></p>

            <!-- ============================================
                 SCANNER 2: SYN STEALTH
                 ============================================ -->
            <p class="section-marker">// IMPLEMENTATION 2: SYN STEALTH SCAN</p>
            <h1>Scanner 2: SYN Scan (Half-Open)</h1>

            <p>
                This scanner sends only SYN packets and analyzes responses WITHOUT completing the
                handshake. When we receive SYN-ACK, we immediately send RST instead of ACK.
                This prevents full connection establishment and reduces logging.
            </p>

            <div class="diagram">
                SYN STEALTH SCAN FLOW:

                SCANNER TARGET
                | |
                | SYN ------------------------------> |
                | <------------------------------ SYN-ACK (OPEN!) | RST ------------------------------> |
                    | ======== CONNECTION NEVER ESTABLISHED ======== |

                    DETECTION LEVEL: MEDIUM (No connection log)
                    PRIVILEGES: ROOT REQUIRED (raw sockets)
            </div>

            <div class="technical-block">
                <div class="technical-block-title">syn_scanner.c</div>
                <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/tcp.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/time.h&gt;

struct pseudo_header {
    uint32_t source_address;
    uint32_t dest_address;
    uint8_t placeholder;
    uint8_t protocol;
    uint16_t tcp_length;
};

unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2)
        sum += *buf++;
    if (len == 1)
        sum += *(unsigned char *)buf;
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int syn_scan_port(const char *src_ip, const char *dst_ip, int port) {
    int sock;
    char packet[4096];
    struct iphdr *ip = (struct iphdr *)packet;
    struct tcphdr *tcp = (struct tcphdr *)(packet + sizeof(struct iphdr));
    struct sockaddr_in dest;
    struct pseudo_header psh;
    char *pseudogram;
    
    sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
    if (sock < 0) {
        perror("Raw socket failed (need root!)");
        return -1;
    }
    
    int one = 1;
    setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one));
    
    memset(packet, 0, 4096);
    
    ip->ihl = 5;
    ip->version = 4;
    ip->tos = 0;
    ip->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr);
    ip->id = htonl(54321);
    ip->frag_off = 0;
    ip->ttl = 64;
    ip->protocol = IPPROTO_TCP;
    ip->check = 0;
    ip->saddr = inet_addr(src_ip);
    ip->daddr = inet_addr(dst_ip);
    
    tcp->source = htons(12345);
    tcp->dest = htons(port);
    tcp->seq = htonl(1105024978);
    tcp->ack_seq = 0;
    tcp->doff = 5;
    tcp->fin = 0;
    tcp->syn = 1;
    tcp->rst = 0;
    tcp->psh = 0;
    tcp->ack = 0;
    tcp->urg = 0;
    tcp->window = htons(5840);
    tcp->check = 0;
    tcp->urg_ptr = 0;
    
    psh.source_address = inet_addr(src_ip);
    psh.dest_address = inet_addr(dst_ip);
    psh.placeholder = 0;
    psh.protocol = IPPROTO_TCP;
    psh.tcp_length = htons(sizeof(struct tcphdr));
    
    int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr);
    pseudogram = malloc(psize);
    memcpy(pseudogram, (char *)&psh, sizeof(struct pseudo_header));
    memcpy(pseudogram + sizeof(struct pseudo_header), tcp, sizeof(struct tcphdr));
    tcp->check = checksum((unsigned short *)pseudogram, psize);
    free(pseudogram);
    
    dest.sin_family = AF_INET;
    dest.sin_port = htons(port);
    dest.sin_addr.s_addr = inet_addr(dst_ip);
    
    if (sendto(sock, packet, ip->tot_len, 0, 
               (struct sockaddr *)&dest, sizeof(dest)) < 0) {
        perror("sendto failed");
        close(sock);
        return -1;
    }
    
    char recv_buffer[4096];
    struct sockaddr_in from;
    socklen_t fromlen = sizeof(from);
    
    struct timeval tv;
    tv.tv_sec = 1;
    tv.tv_usec = 0;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    
    int recv_len = recvfrom(sock, recv_buffer, 4096, 0, 
                            (struct sockaddr *)&from, &fromlen);
    
    close(sock);
    
    if (recv_len > 0) {
        struct iphdr *recv_ip = (struct iphdr *)recv_buffer;
        struct tcphdr *recv_tcp = (struct tcphdr *)(recv_buffer + (recv_ip->ihl * 4));
        
        if (recv_tcp->syn == 1 && recv_tcp->ack == 1) {
            return 1;
        } else if (recv_tcp->rst == 1) {
            return 0;
        }
    }
    
    return -1;
}

int main(int argc, char *argv[]) {
    if (argc != 5) {
        printf("Usage: %s &lt;src_ip&gt; &lt;dst_ip&gt; &lt;start&gt; &lt;end&gt;\n", argv[0]);
        return 1;
    }
    
    printf("[*] SYN STEALTH SCANNER\n");
    printf("[*] %s -> %s | Ports: %s-%s\n\n", argv[1], argv[2], argv[3], argv[4]);
    
    for (int port = atoi(argv[3]); port <= atoi(argv[4]); port++) {
        int result = syn_scan_port(argv[1], argv[2], port);
        if (result == 1) printf("[+] Port %d: OPEN\n", port);
        usleep(10000);
    }
    
    return 0;
}</code></pre>
            </div>

            <h3>Code Breakdown</h3>

            <div class="technical-block">
                <div class="technical-block-title">Why Raw Sockets?</div>
                <p>
                    Normal sockets use the kernel's TCP stack, which automatically completes the handshake.
                    Raw sockets let us craft packets byte-by-byte, controlling every flag. This is why we need
                    root privileges - raw sockets can be used to spoof any packet.
                </p>
            </div>

            <div class="technical-block">
                <div class="technical-block-title">Packet Structure</div>
                <p>We manually build a packet with two headers:</p>
                <ul>
                    <li><strong>IP Header (20 bytes):</strong> Contains source/destination IP, TTL, protocol type</li>
                    <li><strong>TCP Header (20 bytes):</strong> Contains ports, sequence numbers, and FLAGS</li>
                </ul>
                <p>The key line is <code>tcp->syn = 1;</code> - this sets ONLY the SYN flag, creating a half-open scan.
                </p>
            </div>

            <div class="technical-block">
                <div class="technical-block-title">TCP Checksum Calculation</div>
                <p>
                    TCP checksum requires a "pseudo header" containing the source IP, destination IP, and TCP length.
                    This prevents packets from being delivered to wrong hosts. The <code>checksum()</code> function
                    implements the RFC 1071 algorithm (one's complement sum).
                </p>
            </div>

            <div class="technical-block">
                <div class="technical-block-title">Response Analysis</div>
                <table>
                    <tr>
                        <td><code>recv_tcp->syn == 1 && recv_tcp->ack == 1</code></td>
                        <td>SYN-ACK received = Port OPEN</td>
                    </tr>
                    <tr>
                        <td><code>recv_tcp->rst == 1</code></td>
                        <td>RST received = Port CLOSED</td>
                    </tr>
                    <tr>
                        <td>No response (timeout)</td>
                        <td>Port FILTERED by firewall</td>
                    </tr>
                </table>
            </div>

            <p><strong>Compile:</strong> <code>gcc -o syn_scanner syn_scanner.c</code></p>
            <p><strong>Run:</strong> <code>sudo ./syn_scanner 192.168.1.10 192.168.1.1 1 100</code></p>

            <!-- ============================================
                 SCANNER 3: ADVANCED
                 ============================================ -->
            <p class="section-marker">// IMPLEMENTATION 3: ADVANCED MULTI-TECHNIQUE SCANNER</p>
            <h1>Scanner 3: Advanced Scanner with Multiple Techniques</h1>

            <p>
                This advanced scanner implements multiple scan types (SYN, FIN, XMAS, NULL) with
                timing controls, randomized ports, and evasion techniques for maximum stealth.
            </p>

            <div class="diagram">
                ADVANCED SCAN TECHNIQUES:

                FIN SCAN: Send FIN only -> No response = OPEN, RST = CLOSED
                XMAS SCAN: Send FIN+PSH+URG -> No response = OPEN, RST = CLOSED
                NULL SCAN: Send no flags -> No response = OPEN, RST = CLOSED

                EVASION FEATURES:
                - Randomized source port
                - Randomized IP ID
                - Randomized sequence number
                - Random port scan order
                - Random timing delays
            </div>

            <div class="technical-block">
                <div class="technical-block-title">advanced_scanner.c</div>
                <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/tcp.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;

#define SCAN_SYN   0
#define SCAN_FIN   1
#define SCAN_XMAS  2
#define SCAN_NULL  3

struct pseudo_header {
    uint32_t src;
    uint32_t dst;
    uint8_t zero;
    uint8_t protocol;
    uint16_t len;
};

unsigned short calc_checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    for (; len > 1; len -= 2) sum += *buf++;
    if (len == 1) sum += *(unsigned char *)buf;
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    return ~sum;
}

int send_probe(int sock, const char *src, const char *dst, int port, int scan_type) {
    char packet[4096];
    memset(packet, 0, sizeof(packet));
    
    struct iphdr *ip = (struct iphdr *)packet;
    struct tcphdr *tcp = (struct tcphdr *)(packet + sizeof(struct iphdr));
    
    int src_port = (rand() % 60000) + 1024;
    
    ip->ihl = 5;
    ip->version = 4;
    ip->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr);
    ip->id = htons(rand() % 65535);
    ip->ttl = 64;
    ip->protocol = IPPROTO_TCP;
    ip->saddr = inet_addr(src);
    ip->daddr = inet_addr(dst);
    
    tcp->source = htons(src_port);
    tcp->dest = htons(port);
    tcp->seq = htonl(rand());
    tcp->doff = 5;
    tcp->window = htons(1024);
    
    tcp->fin = 0; tcp->syn = 0; tcp->rst = 0;
    tcp->psh = 0; tcp->ack = 0; tcp->urg = 0;
    
    switch (scan_type) {
        case SCAN_SYN:  tcp->syn = 1; break;
        case SCAN_FIN:  tcp->fin = 1; break;
        case SCAN_XMAS: tcp->fin = 1; tcp->psh = 1; tcp->urg = 1; break;
        case SCAN_NULL: break;
    }
    
    struct pseudo_header psh;
    psh.src = inet_addr(src);
    psh.dst = inet_addr(dst);
    psh.zero = 0;
    psh.protocol = IPPROTO_TCP;
    psh.len = htons(sizeof(struct tcphdr));
    
    char *pseudo = malloc(sizeof(psh) + sizeof(struct tcphdr));
    memcpy(pseudo, &psh, sizeof(psh));
    memcpy(pseudo + sizeof(psh), tcp, sizeof(struct tcphdr));
    tcp->check = calc_checksum((unsigned short *)pseudo, sizeof(psh) + sizeof(struct tcphdr));
    free(pseudo);
    
    struct sockaddr_in dest;
    dest.sin_family = AF_INET;
    dest.sin_port = tcp->dest;
    dest.sin_addr.s_addr = inet_addr(dst);
    
    return sendto(sock, packet, ip->tot_len, 0, (struct sockaddr *)&dest, sizeof(dest));
}

int recv_response(int sock, int port, int scan_type) {
    char buffer[4096];
    struct timeval tv = {1, 0};
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    
    struct sockaddr_in from;
    socklen_t fromlen = sizeof(from);
    int len = recvfrom(sock, buffer, sizeof(buffer), 0, (struct sockaddr *)&from, &fromlen);
    
    if (len > 0) {
        struct iphdr *ip = (struct iphdr *)buffer;
        struct tcphdr *tcp = (struct tcphdr *)(buffer + (ip->ihl * 4));
        
        if (ntohs(tcp->source) != port) return -2;
        
        if (scan_type == SCAN_SYN) {
            if (tcp->syn && tcp->ack) return 1;
            if (tcp->rst) return 0;
        } else {
            if (tcp->rst) return 0;
        }
    }
    
    if (scan_type == SCAN_SYN) return -1;
    return 1;
}

void shuffle_ports(int *arr, int n) {
    for (int i = n - 1; i > 0; i--) {
        int j = rand() % (i + 1);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

int main(int argc, char *argv[]) {
    if (argc < 6) {
        printf("Usage: %s &lt;src&gt; &lt;dst&gt; &lt;start&gt; &lt;end&gt; &lt;type&gt;\n", argv[0]);
        printf("Types: syn, fin, xmas, null\n");
        return 1;
    }
    
    int scan_type;
    if (strcmp(argv[5], "syn") == 0) scan_type = SCAN_SYN;
    else if (strcmp(argv[5], "fin") == 0) scan_type = SCAN_FIN;
    else if (strcmp(argv[5], "xmas") == 0) scan_type = SCAN_XMAS;
    else if (strcmp(argv[5], "null") == 0) scan_type = SCAN_NULL;
    else { printf("Invalid type\n"); return 1; }
    
    int sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
    if (sock < 0) { perror("Socket failed"); return 1; }
    
    int one = 1;
    setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one));
    
    srand(time(NULL));
    
    int start = atoi(argv[3]), end = atoi(argv[4]);
    int num_ports = end - start + 1;
    int *ports = malloc(num_ports * sizeof(int));
    for (int i = 0; i < num_ports; i++) ports[i] = start + i;
    shuffle_ports(ports, num_ports);
    
    printf("[*] ADVANCED SCANNER | Method: %s\n", argv[5]);
    printf("[*] %s -> %s | Ports: %d-%d\n\n", argv[1], argv[2], start, end);
    
    for (int i = 0; i < num_ports; i++) {
        usleep((rand() % 40000) + 10000);
        send_probe(sock, argv[1], argv[2], ports[i], scan_type);
        int result = recv_response(sock, ports[i], scan_type);
        if (result == 1) printf("[+] Port %d: OPEN\n", ports[i]);
    }
    
    free(ports);
    close(sock);
    return 0;
}</code></pre>
            </div>

            <h3>Code Breakdown</h3>

            <div class="technical-block">
                <div class="technical-block-title">Scan Type Selection</div>
                <p>The switch statement sets different TCP flags based on scan type:</p>
                <table>
                    <tr>
                        <td><strong>SYN</strong></td>
                        <td><code>tcp->syn = 1</code></td>
                        <td>Standard stealth scan</td>
                    </tr>
                    <tr>
                        <td><strong>FIN</strong></td>
                        <td><code>tcp->fin = 1</code></td>
                        <td>Only FIN flag - bypasses some firewalls</td>
                    </tr>
                    <tr>
                        <td><strong>XMAS</strong></td>
                        <td><code>tcp->fin = tcp->psh = tcp->urg = 1</code></td>
                        <td>Multiple flags "lit up like Christmas tree"</td>
                    </tr>
                    <tr>
                        <td><strong>NULL</strong></td>
                        <td>All flags = 0</td>
                        <td>No flags set - minimal packet footprint</td>
                    </tr>
                </table>
            </div>

            <div class="technical-block">
                <div class="technical-block-title">Evasion Techniques</div>
                <ul>
                    <li><strong>Random Source Port:</strong> <code>rand() % 60000 + 1024</code> - Different source port
                        each probe</li>
                    <li><strong>Random IP ID:</strong> <code>rand() % 65535</code> - Prevents IP ID tracking</li>
                    <li><strong>Random Sequence:</strong> <code>rand()</code> - Unpredictable sequence numbers</li>
                    <li><strong>Port Shuffling:</strong> <code>shuffle_ports()</code> - Scans ports in random order</li>
                    <li><strong>Random Delays:</strong> <code>usleep(rand() % 40000 + 10000)</code> - 10-50ms random
                        delay</li>
                </ul>
            </div>

            <div class="technical-block">
                <div class="technical-block-title">Why FIN/XMAS/NULL Work</div>
                <p>
                    According to RFC 793, if a closed port receives a packet without SYN, it must respond
                    with RST. Open ports should silently drop these packets. This is why no response
                    indicates an open port.
                </p>
                <p>
                    <strong>Limitation:</strong> Windows TCP stack ignores RFC 793 and sends RST for all
                    ports regardless of state. These scans only work reliably against Unix/Linux systems.
                </p>
            </div>

            <p><strong>Compile:</strong> <code>gcc -o advanced_scanner advanced_scanner.c</code></p>
            <p><strong>Run:</strong> <code>sudo ./advanced_scanner 10.0.0.5 10.0.0.1 1 100 xmas</code></p>

            <!-- ============================================
                 SUMMARY
                 ============================================ -->
            <h2>Summary Table</h2>

            <table>
                <thead>
                    <tr>
                        <th>Scanner</th>
                        <th>Technique</th>
                        <th>Stealth</th>
                        <th>Root?</th>
                        <th>Works On</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Basic</td>
                        <td>Full connect()</td>
                        <td>LOW</td>
                        <td>No</td>
                        <td>All</td>
                    </tr>
                    <tr>
                        <td>SYN</td>
                        <td>Half-open SYN</td>
                        <td>MEDIUM</td>
                        <td>Yes</td>
                        <td>All</td>
                    </tr>
                    <tr>
                        <td>Advanced</td>
                        <td>SYN/FIN/XMAS/NULL</td>
                        <td>HIGH</td>
                        <td>Yes</td>
                        <td>Unix/Linux</td>
                    </tr>
                </tbody>
            </table>

        </div>
    </main>

    <footer class="site-footer">
        <p class="footer-text">
            Module 3: Port Scanner Implementation // Field Manual<br>
            Classification: Unclassified
        </p>
    </footer>
    <script src="../search.js"></script>
</body>

</html>