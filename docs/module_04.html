<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MODULE 04: GOD MODE</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <h1>MODULE 04: GOD MODE</h1>
    <p><a href="index.html" class="nav-item" style="display:inline-block;padding:8px 15px;">← BACK TO INDEX</a></p>

    <!-- ═══════════════════════════════════════════════════════════════════════
         MANIFESTO
    ════════════════════════════════════════════════════════════════════════ -->

    <div class="real-talk">
        <strong>THE ULTIMATE DISCIPLINE:</strong> Game hacking is not child's play. It is the
        ultimate test of systems engineering—a crucible where reverse engineering, mathematics,
        and kernel-level programming collide. You must understand binary formats to find game
        structures. You must understand trigonometry to aim. You must understand memory management
        to read enemy positions. You must understand the operating system to hide your presence.<br><br>

        This module tears apart the mechanics of competitive game exploitation. We build aimbots
        that calculate trajectories in 3D space. We read memory across process boundaries. We
        inject code into running games. Every technique here translates directly to security
        research, anti-cheat development, and systems programming at the deepest level.<br><br>

        <em>The skills are the same. Only the target changes.</em>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════════
         PART I: ARCHITECTURE (INTERNAL VS EXTERNAL)
    ════════════════════════════════════════════════════════════════════════ -->

    <h2>Part I: Architecture (Internal vs. External)</h2>

    <p>
        Before writing a single line of hack code, you must choose your architecture. There
        are two fundamental approaches to game manipulation, each with distinct trade-offs
        in power, speed, and stealth. This choice affects everything that follows.
    </p>

    <!-- ═══════════════════════════════════════════════════════════════════════
         EXTERNAL (THE GHOST)
    ════════════════════════════════════════════════════════════════════════ -->

    <h3>External (The Ghost)</h3>

    <p>
        An <strong>external hack</strong> runs as a separate process—completely outside the
        game. It reads game memory through operating system APIs, processes that data in its
        own address space, and optionally writes back modifications. The game never knows
        your code exists inside it because it doesn't.
    </p>

    <div class="code-block">
        EXTERNAL ARCHITECTURE:
        ═════════════════════════════════════════════════════════════════════════════

        ┌─────────────────────────┐ ┌─────────────────────────────────────┐
        │ YOUR HACK.EXE │ │ GAME PROCESS │
        │ (Separate Process) │ │ │
        │ │ │ ┌─────────────────────────────┐ │
        │ ┌───────────────────┐ │ │ │ Player Position │ │
        │ │ Read Memory Loop │◀─┼────────┼──│ 0x7FF612340000 │ │
        │ │ │ │ OS │ │ x: 150.5, y: 200.3, z: 50 │ │
        │ │ Calculate Angles │ │ API │ └─────────────────────────────┘ │
        │ │ │ │ │ │
        │ │ Draw ESP Overlay │ │ │ ┌─────────────────────────────┐ │
        │ └───────────────────┘ │ │ │ Enemy Array │ │
        │ │ │ │ 0x7FF612350000 │ │
        └─────────────────────────┘ │ │ [0]: x,y,z [1]: x,y,z ... │ │
        │ └─────────────────────────────┘ │
        │ │
        └─────────────────────────────────────┘

        ═════════════════════════════════════════════════════════════════════════════

        WINDOWS IMPLEMENTATION:
        ─────────────────────────────────────────────────────────────────────────────

        #include <windows.h>

            // Open handle to game process
            HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE,
            FALSE, gameProcessId);

            // Read memory from game
            float playerX;
            ReadProcessMemory(hProcess,
            (LPCVOID)0x7FF612340000, // Address in game
            &playerX, // Buffer in our process
            sizeof(float), // Size to read
            NULL); // Bytes read (optional)

            // Write memory to game (e.g., set health to 9999)
            int newHealth = 9999;
            WriteProcessMemory(hProcess,
            (LPVOID)0x7FF612348000,
            &newHealth,
            sizeof(int),
            NULL);

            ═════════════════════════════════════════════════════════════════════════════

            KEY CHARACTERISTICS:
            ─────────────────────────────────────────────────────────────────────────────

            ✓ Runs in separate process — crash safety (game crash ≠ hack crash)
            ✓ Easier to develop and debug — use normal debugger on your hack
            ✓ No modification of game files — harder to detect via file integrity

            ✗ Slower — every memory read goes through kernel
            ✗ Detectable via handle enumeration (anti-cheat can see who opened handle)
            ✗ Limited functionality — can't hook game functions directly
            ✗ Some games block external access entirely
    </div>

    <h4>Linux Special: process_vm_readv (The Speed Advantage)</h4>

    <p>
        On Linux, external memory access is significantly faster than Windows. While Windows
        requires the kernel to copy memory between processes, Linux provides
        <code>process_vm_readv()</code>—a system call that performs <strong>direct
            cross-process memory transfer</strong> without intermediate copies.
    </p>

    <div class="code-block">
        LINUX process_vm_readv — FASTER THAN WINDOWS:
        ═════════════════════════════════════════════════════════════════════════════

        WHY IT'S FASTER:
        ─────────────────────────────────────────────────────────────────────────────

        Windows ReadProcessMemory:
        1. User mode → Kernel mode transition
        2. Kernel copies from target to KERNEL BUFFER
        3. Kernel copies from KERNEL BUFFER to your process
        4. Kernel mode → User mode transition

        Total: 2 memory copies + 2 mode switches

        Linux process_vm_readv:
        1. User mode → Kernel mode transition
        2. Kernel maps target memory, DIRECT COPY to your buffer
        3. Kernel mode → User mode transition

        Total: 1 memory copy + 2 mode switches

        For reading megabytes of game state per frame, this difference is MASSIVE.

        ═════════════════════════════════════════════════════════════════════════════

        C FUNCTION PROTOTYPE:
        ─────────────────────────────────────────────────────────────────────────────

        #define _GNU_SOURCE
        #include <sys /uio.h>

            ssize_t process_vm_readv(
            pid_t pid, // Target process ID
            const struct iovec *local_iov, // Array of LOCAL buffers (your process)
            unsigned long liovcnt, // Number of local buffers
            const struct iovec *remote_iov, // Array of REMOTE addresses (game)
            unsigned long riovcnt, // Number of remote regions
            unsigned long flags // Reserved, must be 0
            );

            // Returns: Number of bytes read, or -1 on error

            ═════════════════════════════════════════════════════════════════════════════

            PRACTICAL EXAMPLE — Reading Player Position:
            ─────────────────────────────────────────────────────────────────────────────

            #define _GNU_SOURCE
            #include <sys /uio.h>
                #include <stdio.h>
                    #include <stdint.h>

                        typedef struct {
                        float x, y, z;
                        } Vec3;

                        int read_player_position(pid_t game_pid, uintptr_t player_addr, Vec3 *out) {
                        struct iovec local[1];
                        struct iovec remote[1];

                        // Local buffer: where to store the read data
                        local[0].iov_base = out;
                        local[0].iov_len = sizeof(Vec3);

                        // Remote address: where to read from in the game
                        remote[0].iov_base = (void *)player_addr;
                        remote[0].iov_len = sizeof(Vec3);

                        ssize_t nread = process_vm_readv(game_pid, local, 1, remote, 1, 0);

                        if (nread != sizeof(Vec3)) {
                        perror("process_vm_readv failed");
                        return -1;
                        }

                        return 0; // Success
                        }

                        int main() {
                        pid_t game_pid = 12345; // Find this with pgrep or /proc enumeration
                        uintptr_t player_base = 0x7F1234560000; // Found via reversing

                        Vec3 pos;
                        if (read_player_position(game_pid, player_base + 0x100, &pos) == 0) {
                        printf("Player at: (%.2f, %.2f, %.2f)\n", pos.x, pos.y, pos.z);
                        }

                        return 0;
                        }

                        ═════════════════════════════════════════════════════════════════════════════

                        SCATTER-GATHER READS (Reading Multiple Regions at Once):
                        ─────────────────────────────────────────────────────────────────────────────

                        // Read player pos AND enemy array in ONE syscall
                        Vec3 player_pos;
                        Vec3 enemies[64];

                        struct iovec local[2] = {
                        { .iov_base = &player_pos, .iov_len = sizeof(Vec3) },
                        { .iov_base = enemies, .iov_len = sizeof(enemies) }
                        };

                        struct iovec remote[2] = {
                        { .iov_base = (void*)0x7F1234560100, .iov_len = sizeof(Vec3) },
                        { .iov_base = (void*)0x7F1234570000, .iov_len = sizeof(enemies) }
                        };

                        // Single syscall reads BOTH regions!
                        process_vm_readv(game_pid, local, 2, remote, 2, 0);
    </div>

    <div class="warn-banner">
        <strong>Permissions:</strong> process_vm_readv requires appropriate permissions.
        Either run as root, or the target process must be ptrace-able (same user,
        <code>/proc/sys/kernel/yama/ptrace_scope</code> must allow it). For game hacking,
        you typically need CAP_SYS_PTRACE or root.
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════════
         INTERNAL (THE PARASITE)
    ════════════════════════════════════════════════════════════════════════ -->

    <h3>Internal (The Parasite)</h3>

    <p>
        An <strong>internal hack</strong> injects code directly into the game's address space.
        Your code becomes part of the game process itself. You have direct pointer access to
        all game data structures—no system calls, no kernel transitions. This is maximum power
        at maximum risk.
    </p>

    <div class="code-block">
        INTERNAL ARCHITECTURE:
        ═════════════════════════════════════════════════════════════════════════════

        ┌─────────────────────────────────────────────────────────────────────────┐
        │ GAME PROCESS │
        │ │
        │ ┌─────────────────────────────────────────────────────────────────┐ │
        │ │ GAME CODE (.text) │ │
        │ │ render_frame() │ │
        │ │ update_players() │ │
        │ │ check_hit() ◀─────────── HOOKED! Redirects to your code │ │
        │ └─────────────────────────────────────────────────────────────────┘ │
        │ │
        │ ┌─────────────────────────────────────────────────────────────────┐ │
        │ │ GAME DATA (.data) │ │
        │ │ Player* localPlayer = 0x12340000 │ │
        │ │ EntityList* entities = 0x12350000 │ │
        │ └─────────────────────────────────────────────────────────────────┘ │
        │ │
        │ ┌─────────────────────────────────────────────────────────────────┐ │
        │ │ ██ YOUR INJECTED CODE (hack.dll / hack.so) ██ │ │
        │ │ │ │
        │ │ void hack_thread() { │ │
        │ │ // DIRECT POINTER ACCESS — no syscalls! │ │
        │ │ Player* me = *(Player**)0x12340000; │ │
        │ │ float x = me->position.x; // Just a pointer deref │ │
        │ │ │ │
        │ │ // Can hook game functions │ │
        │ │ // Can call game functions │ │
        │ │ // Full access to everything │ │
        │ │ } │ │
        │ └─────────────────────────────────────────────────────────────────┘ │
        │ │
        └─────────────────────────────────────────────────────────────────────────┘

        ═════════════════════════════════════════════════════════════════════════════

        INJECTION METHODS:
        ─────────────────────────────────────────────────────────────────────────────

        WINDOWS:
        1. CreateRemoteThread + LoadLibraryA
        - Allocate memory in target, write DLL path, create thread calling LoadLibrary

        2. Manual Mapping
        - Parse your DLL, manually map sections, resolve imports, call DllMain
        - Doesn't appear in module list (more stealthy)

        3. Thread Hijacking
        - Suspend existing thread, modify RIP to point to your code, resume

        LINUX:
        1. LD_PRELOAD
        - Set environment variable before game launch: LD_PRELOAD=./hack.so
        - Your .so loads before game, can hook anything during initialization

        2. ptrace injection
        - Attach with ptrace, write shellcode, execute dlopen() for your .so

        3. /proc/pid/mem + syscall injection
        - Write code directly to game memory, manipulate registers

        ═════════════════════════════════════════════════════════════════════════════

        POINTER ACCESS SPEED (Internal):
        ─────────────────────────────────────────────────────────────────────────────

        // External (ReadProcessMemory): ~1000+ CPU cycles per read
        float health;
        ReadProcessMemory(hProcess, healthAddr, &health, sizeof(float), NULL);

        // Internal (Direct Pointer): ~1-3 CPU cycles per read
        float health = *(float*)healthAddr;

        For reading 1000 entities × 10 values each = 10,000 reads per frame:
        - External: 10,000,000+ cycles = SIGNIFICANT overhead
        - Internal: 30,000 cycles = NEGLIGIBLE

        This is why competitive cheats are almost always internal.
    </div>

    <div class="real-talk">
        <strong>The catch:</strong> Internal hacks live inside the game. If the game crashes,
        your code is gone. If the anti-cheat scans loaded modules, your DLL is visible. If
        the anti-cheat checksums game memory, your hooks are detected. Internal hacks are
        more powerful but require sophisticated evasion techniques to survive.
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════════
         COMPARISON TABLE
    ════════════════════════════════════════════════════════════════════════ -->

    <h3>Architecture Comparison</h3>

    <table style="width:100%; border-collapse:collapse; margin:20px 0;">
        <tr style="border-bottom:3px solid #ff0000; background-color:#111;">
            <th style="text-align:left; padding:15px; border:1px solid #333; width:20%;">Aspect</th>
            <th style="text-align:left; padding:15px; border:1px solid #333; width:40%;">
                <span style="color:#4ecdc4;">EXTERNAL</span> (Ghost)
            </th>
            <th style="text-align:left; padding:15px; border:1px solid #333; width:40%;">
                <span style="color:#ff6b6b;">INTERNAL</span> (Parasite)
            </th>
        </tr>
        <tr>
            <td style="padding:15px; border:1px solid #333;"><strong>Memory Access</strong></td>
            <td style="padding:15px; border:1px solid #333;">
                OS API (ReadProcessMemory / process_vm_readv)<br>
                <span style="color:#888;">~1000+ cycles per read</span>
            </td>
            <td style="padding:15px; border:1px solid #333;">
                Direct pointer dereference<br>
                <span style="color:#4ecdc4;">~1-3 cycles per read</span>
            </td>
        </tr>
        <tr>
            <td style="padding:15px; border:1px solid #333;"><strong>Function Hooking</strong></td>
            <td style="padding:15px; border:1px solid #333;">
                <span style="color:#ff6b6b;">✗ Not possible</span><br>
                Cannot intercept game functions
            </td>
            <td style="padding:15px; border:1px solid #333;">
                <span style="color:#4ecdc4;">✓ Full power</span><br>
                Hook any function, call game functions
            </td>
        </tr>
        <tr>
            <td style="padding:15px; border:1px solid #333;"><strong>Detection Surface</strong></td>
            <td style="padding:15px; border:1px solid #333;">
                Handle enumeration (who has handle to game?)<br>
                Window enumeration (overlay windows)<br>
                <span style="color:#4ecdc4;">Smaller footprint</span>
            </td>
            <td style="padding:15px; border:1px solid #333;">
                Module enumeration (DLL/SO list)<br>
                Memory integrity checks<br>
                Hook detection<br>
                <span style="color:#ff6b6b;">Larger footprint</span>
            </td>
        </tr>
        <tr>
            <td style="padding:15px; border:1px solid #333;"><strong>Crash Safety</strong></td>
            <td style="padding:15px; border:1px solid #333;">
                <span style="color:#4ecdc4;">✓ Isolated</span><br>
                Hack crash ≠ Game crash
            </td>
            <td style="padding:15px; border:1px solid #333;">
                <span style="color:#ff6b6b;">✗ Shared fate</span><br>
                Bug in hack = Game crash
            </td>
        </tr>
        <tr>
            <td style="padding:15px; border:1px solid #333;"><strong>Development</strong></td>
            <td style="padding:15px; border:1px solid #333;">
                <span style="color:#4ecdc4;">✓ Easier</span><br>
                Standard debugger works on your process
            </td>
            <td style="padding:15px; border:1px solid #333;">
                <span style="color:#ff6b6b;">✗ Harder</span><br>
                Debugging injected code is complex
            </td>
        </tr>
        <tr>
            <td style="padding:15px; border:1px solid #333;"><strong>Use Case</strong></td>
            <td style="padding:15px; border:1px solid #333;">
                Radar hacks, ESP overlays<br>
                Memory editors, trainers<br>
                <span style="color:#888;">Games without aggressive AC</span>
            </td>
            <td style="padding:15px; border:1px solid #333;">
                Aimbots, triggerbots<br>
                Full game manipulation<br>
                <span style="color:#888;">Competitive games (with evasion)</span>
            </td>
        </tr>
    </table>

    <!-- ═══════════════════════════════════════════════════════════════════════
         PART II: THE MATHEMATICS OF VIOLENCE (AIMBOTS)
    ════════════════════════════════════════════════════════════════════════ -->

    <h2>Part II: The Mathematics of Violence (Aimbots)</h2>

    <p>
        An aimbot does one thing: point your crosshair at an enemy's head. This sounds simple
        until you realize the problem requires converting 3D world coordinates into 2D screen
        angles. The game world is three-dimensional. Your mouse controls a 2D rotation (yaw
        and pitch). Bridging this gap requires trigonometry.
    </p>

    <!-- ═══════════════════════════════════════════════════════════════════════
         THE PROBLEM
    ════════════════════════════════════════════════════════════════════════ -->

    <h3>The Problem</h3>

    <div class="code-block">
        THE AIMBOT PROBLEM:
        ═════════════════════════════════════════════════════════════════════════════

        YOU HAVE:
        ─────────────────────────────────────────────────────────────────────────────

        Your Position (camera): myPos = (100.0, 50.0, 25.0) // x, y, z
        Enemy Head Position: enemyPos = (250.0, 75.0, 30.0) // x, y, z

        ═════════════════════════════════════════════════════════════════════════════

        YOU NEED:
        ─────────────────────────────────────────────────────────────────────────────

        Camera Angles: yaw = ??? (left/right rotation, degrees)
        pitch = ??? (up/down rotation, degrees)

        ═════════════════════════════════════════════════════════════════════════════

        Y (up)
        │
        │ ☠ Enemy (250, 75, 30)
        │ /
        │ / ← We need this angle!
        │ /
        │/θ (pitch)
        ─────────────●─────────────── X (right)
        /│ You (100, 50, 25)
        / │
        / │
        / │
        Z (forward)

        φ (yaw) = angle around Y axis
        θ (pitch) = angle around X axis

        ═════════════════════════════════════════════════════════════════════════════

        THE CORE CHALLENGE:

        The game stores 3D coordinates.
        The player's view is controlled by 2D angles.
        We must project 3D → 2D angles.
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════════
         THE SOLUTION: MATHEMATICS
    ════════════════════════════════════════════════════════════════════════ -->

    <h3>The Solution: Mathematics</h3>

    <h4>Step 1: The Delta Vector</h4>

    <p>
        First, we need the <strong>direction vector</strong> from your position to the enemy.
        This is computed by subtracting your position from the enemy's position. The result
        is a vector pointing from you toward the target.
    </p>

    <div class="code-block">
        THE DELTA VECTOR (Direction to Target):
        ═════════════════════════════════════════════════════════════════════════════

        FORMULA:
        ─────────────────────────────────────────────────────────────────────────────

        delta = enemyPos - myPos

        delta.x = enemyPos.x - myPos.x = 250.0 - 100.0 = 150.0
        delta.y = enemyPos.y - myPos.y = 75.0 - 50.0 = 25.0
        delta.z = enemyPos.z - myPos.z = 30.0 - 25.0 = 5.0

        delta = (150.0, 25.0, 5.0)

        ═════════════════════════════════════════════════════════════════════════════

        WHY SUBTRACT?
        ─────────────────────────────────────────────────────────────────────────────

        Your position is the ORIGIN of your view. You don't care about absolute
        world coordinates—you care about WHERE THE ENEMY IS RELATIVE TO YOU.

        Subtracting your position centers the calculation at your location.
        The delta vector now represents: "go this far in X, this far in Y,
        this far in Z to reach the enemy from where you stand."

        This is the vector we need to convert into angles.
    </div>

    <h4>Step 2: Euclidean Distance (3D Pythagorean Theorem)</h4>

    <p>
        To calculate the pitch angle, we need the <strong>horizontal distance</strong> to the
        target. This is the distance in the XZ plane (ground plane), ignoring height. We use
        the Euclidean distance formula—the 3D extension of the Pythagorean theorem.
    </p>

    <div class="code-block">
        EUCLIDEAN DISTANCE:
        ═════════════════════════════════════════════════════════════════════════════

        HORIZONTAL DISTANCE (XZ plane):
        ─────────────────────────────────────────────────────────────────────────────

        We need the distance along the ground to calculate pitch.
        This ignores the Y (vertical) component.

        horizontalDist = √(delta.x² + delta.z²)
        = √(150.0² + 5.0²)
        = √(22500 + 25)
        = √22525
        = 150.08 (approximately)

        ═════════════════════════════════════════════════════════════════════════════

        FULL 3D DISTANCE (if needed):
        ─────────────────────────────────────────────────────────────────────────────

        distance3D = √(delta.x² + delta.y² + delta.z²)
        = √(150.0² + 25.0² + 5.0²)
        = √(22500 + 625 + 25)
        = √23150
        = 152.15

        ═════════════════════════════════════════════════════════════════════════════

        THE PYTHAGOREAN THEOREM IN 3D:
        ─────────────────────────────────────────────────────────────────────────────

        * Enemy
        /|
        / |
        / | delta.y (height difference)
        / |
        / |
        /θ |
        You ●─────────────┼
        \____________/
        │
        horizontalDist
        (√(x² + z²))

        The pitch angle (θ) is the angle between the horizontal plane
        and the line to the enemy. We need horizontalDist to calculate it.
    </div>

    <h4>Step 3: Trigonometry — atan2 (The Angle Extractor)</h4>

    <p>
        <strong><code>atan2(y, x)</code></strong> is the most important function in game
        hacking math. It takes two coordinates and returns the angle (in radians) from the
        positive X-axis to the point (x, y). This is how we convert position differences
        into rotation angles.
    </p>

    <div class="code-block">
        UNDERSTANDING atan2:
        ═════════════════════════════════════════════════════════════════════════════

        WHAT IS atan2?
        ─────────────────────────────────────────────────────────────────────────────

        atan2(y, x) returns the angle θ such that:

        x = r × cos(θ)
        y = r × sin(θ)

        Where r is the distance from origin to point (x, y).

        Result is in RADIANS, range: [-π, +π] (i.e., -180° to +180°)

        ═════════════════════════════════════════════════════════════════════════════

        WHY NOT JUST USE atan(y/x)?
        ─────────────────────────────────────────────────────────────────────────────

        atan(y/x) has two fatal problems:

        1. Division by zero when x = 0
        2. Wrong quadrant — atan only returns angles in [-90°, +90°]
        It can't distinguish between (1,1) and (-1,-1)!

        atan2 fixes BOTH problems:
        - Handles x = 0 correctly
        - Returns correct angle for all four quadrants

        ═════════════════════════════════════════════════════════════════════════════

        VISUAL REPRESENTATION:
        ─────────────────────────────────────────────────────────────────────────────

        Y
        │ Q2 Q1
        │ ╲ ╱
        │ ╲ ╱
        │ ╲ θ ╱
        ───┼──────●─────────── X
        │ ╱ ╲
        │ ╱ ╲
        │ ╱ ╲
        │ Q3 Q4

        atan2(y, x) returns θ measured COUNTER-CLOCKWISE from positive X-axis.

        Examples:
        atan2(0, 1) = 0° (pointing right)
        atan2(1, 0) = 90° (pointing up)
        atan2(0, -1) = 180° (pointing left)
        atan2(-1, 0) = -90° (pointing down)

        ═════════════════════════════════════════════════════════════════════════════

        APPLYING TO AIMBOT:
        ─────────────────────────────────────────────────────────────────────────────

        YAW (horizontal rotation, looking left/right):
        ────────────────────────────────────────────────

        We want the angle in the XZ plane (ground plane).

        yaw = atan2(delta.x, delta.z)

        NOTE: Order depends on game's coordinate system!
        Some games use atan2(delta.z, delta.x)
        Experiment to find what works.

        PITCH (vertical rotation, looking up/down):
        ────────────────────────────────────────────────

        We want the angle between horizontal and the line to target.

        pitch = atan2(delta.y, horizontalDistance)
        = atan2(delta.y, √(delta.x² + delta.z²))

        Negative pitch = looking up (target above you)
        Positive pitch = looking down (target below you)
        (Or vice versa, depending on game!)

        ═════════════════════════════════════════════════════════════════════════════

        CONVERTING RADIANS TO DEGREES:
        ─────────────────────────────────────────────────────────────────────────────

        Most games use degrees for view angles.

        degrees = radians × (180.0 / π)
        radians = degrees × (π / 180.0)

        #define RAD2DEG(x) ((x) * (180.0 / M_PI))
        #define DEG2RAD(x) ((x) * (M_PI / 180.0))
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════════
         THE CODE — PURE C IMPLEMENTATION
    ════════════════════════════════════════════════════════════════════════ -->

    <h3>The Code: Pure C Implementation</h3>

    <div class="code-block">
        AIMBOT ANGLE CALCULATION — PURE C:
        ═════════════════════════════════════════════════════════════════════════════

        #include &lt;math.h&gt;

        // Vector3 structure for positions
        typedef struct {
        float x, y, z;
        } Vec3;

        // Angle structure for yaw/pitch
        typedef struct {
        float yaw; // Horizontal rotation (left/right)
        float pitch; // Vertical rotation (up/down)
        } Angles;

        // Convert radians to degrees
        #define RAD2DEG(r) ((r) * (180.0f / M_PI))

        /**
        * CalculateAngles - Compute aiming angles from source to destination
        *
        * @param src Your position (camera position)
        * @param dst Target position (enemy head)
        * @return Angles needed to aim at target
        */
        Angles CalculateAngles(Vec3 src, Vec3 dst) {
        Angles angles;

        // ═══════════════════════════════════════════════════════════════════
        // STEP 1: Calculate the Delta Vector
        // ═══════════════════════════════════════════════════════════════════
        // Subtract our position from enemy position.
        // This gives us the direction and distance to the target.

        float delta_x = dst.x - src.x;
        float delta_y = dst.y - src.y;
        float delta_z = dst.z - src.z;

        // ═══════════════════════════════════════════════════════════════════
        // STEP 2: Calculate Horizontal Distance
        // ═══════════════════════════════════════════════════════════════════
        // The distance along the ground plane (XZ), ignoring height.
        // This is needed for the pitch calculation.

        float horizontal_dist = sqrtf(delta_x * delta_x + delta_z * delta_z);

        // ═══════════════════════════════════════════════════════════════════
        // STEP 3: Calculate Yaw (Horizontal Angle)
        // ═══════════════════════════════════════════════════════════════════
        // atan2 gives us the angle from the forward direction (Z) to the
        // target in the horizontal plane.
        //
        // Note: The order of arguments (x, z vs z, x) depends on the game's
        // coordinate system. Many games use -atan2(delta_x, delta_z).

        angles.yaw = RAD2DEG(atan2f(delta_x, delta_z));

        // ═══════════════════════════════════════════════════════════════════
        // STEP 4: Calculate Pitch (Vertical Angle)
        // ═══════════════════════════════════════════════════════════════════
        // atan2 of the height difference over horizontal distance.
        // Negative because most games have negative pitch = looking up.

        angles.pitch = RAD2DEG(-atan2f(delta_y, horizontal_dist));

        return angles;
        }

        ═════════════════════════════════════════════════════════════════════════════

        EXAMPLE USAGE:
        ─────────────────────────────────────────────────────────────────────────────

        #include &lt;stdio.h&gt;

        int main() {
        // Your position (read from game memory)
        Vec3 myPos = { 100.0f, 50.0f, 25.0f };

        // Enemy head position (read from game memory)
        Vec3 enemyHead = { 250.0f, 75.0f, 30.0f };

        // Calculate angles
        Angles aim = CalculateAngles(myPos, enemyHead);

        printf("Aim Angles:\n");
        printf(" Yaw: %.2f degrees\n", aim.yaw);
        printf(" Pitch: %.2f degrees\n", aim.pitch);

        // In a real aimbot, you would now:
        // 1. Write these angles to the game's view angle address
        // 2. Or calculate mouse movement to reach these angles
        // 3. Or use the game's SetViewAngles function (if internal)

        return 0;
        }

        ═════════════════════════════════════════════════════════════════════════════

        OUTPUT:
        ─────────────────────────────────────────────────────────────────────────────

        Aim Angles:
        Yaw: 88.09 degrees
        Pitch: -9.46 degrees

        ═════════════════════════════════════════════════════════════════════════════

        IMPORTANT NOTES:
        ─────────────────────────────────────────────────────────────────────────────

        1. COORDINATE SYSTEMS VARY BY GAME
        - Some games: Y is up, Z is forward
        - Some games: Z is up, Y is forward
        - Some games: Yaw 0 = North, some = East

        You MUST reverse engineer the specific game to know which convention
        it uses. Swap X/Y/Z and negate values until it works.

        2. ANGLE CLAMPING
        Many games clamp angles:
        - Pitch: typically [-89, +89] degrees (can't look straight up/down)
        - Yaw: typically [0, 360) or [-180, +180]

        Your calculated angles must respect these limits.

        3. ANGLE NORMALIZATION
        If yaw exceeds 180 or goes below -180, wrap it:

        while (angles.yaw > 180.0f) angles.yaw -= 360.0f;
        while (angles.yaw < -180.0f) angles.yaw +=360.0f; 4. SMOOTHING (for human-like aim) Raw angle snapping is
            obvious. Real aimbots interpolate: current_yaw +=(target_yaw - current_yaw) * smoothing_factor; </div>

            <div class="warn-banner">
                <strong>Compile with math library:</strong> On Linux/GCC, you must link the math
                library explicitly: <code>gcc aimbot.c -o aimbot -lm</code>. The <code>-lm</code>
                flag is required for <code>sqrtf</code>, <code>atan2f</code>, and other math functions.
            </div>

            <!-- ═══════════════════════════════════════════════════════════════════════
         PART III: THE MATRIX (ESP & WORLD-TO-SCREEN)
    ════════════════════════════════════════════════════════════════════════ -->

            <h2>Part III: The Matrix (ESP & World-to-Screen)</h2>

            <p>
                ESP (Extra Sensory Perception) overlays show you where enemies are—boxes around
                players, health bars, names floating above heads. But here's the problem: enemies
                exist in 3D space, and your monitor is a 2D rectangle. How do you convert a 3D
                position like <code>(1250.5, 340.2, 89.0)</code> into a 2D pixel coordinate like
                <code>(960, 540)</code>? The answer is the <strong>View Matrix</strong>.
            </p>

            <!-- ═══════════════════════════════════════════════════════════════════════
         THE PROBLEM
    ════════════════════════════════════════════════════════════════════════ -->

            <h3>The Problem: 3D to 2D Projection</h3>

            <div class="code-block">
                THE ESP PROBLEM:
                ═════════════════════════════════════════════════════════════════════════════

                YOU HAVE:
                ─────────────────────────────────────────────────────────────────────────────

                Enemy position in 3D world space:
                enemyHead = (1250.5, 340.2, 89.0) // x, y, z in world units

                ═════════════════════════════════════════════════════════════════════════════

                YOU NEED:
                ─────────────────────────────────────────────────────────────────────────────

                Screen position in 2D pixels:
                screenPos = (960, 540) // x, y in pixels on your 1920x1080 monitor

                ═════════════════════════════════════════════════════════════════════════════

                THE CHALLENGE:
                ─────────────────────────────────────────────────────────────────────────────

                3D WORLD 2D SCREEN
                (pixels)
                Y │ ┌──────────────────┐
                │ ☠ Enemy │ │
                │ (1250, 340, 89) │ ┌───┐ │
                │ / │ │ ☠ │ │
                │ / ← HOW DO WE GET │ └───┘ │
                │ / SCREEN COORDS? │ (960,540) │
                │ / │ │
                ●───────────────── X └──────────────────┘
                / You 0,0 ────→ X
                Z │
                ↓ Y

                The game engine already solves this problem for rendering.
                It uses a MATRIX to project 3D points onto the 2D screen.
                We just need to steal that matrix and use it ourselves.
            </div>

            <!-- ═══════════════════════════════════════════════════════════════════════
         THE VIEW MATRIX
    ════════════════════════════════════════════════════════════════════════ -->

            <h3>The View Matrix: The 4x4 Grid of Floats</h3>

            <p>
                Every 3D game engine uses a <strong>View-Projection Matrix</strong> (often just called
                the View Matrix) to transform 3D world coordinates into 2D screen coordinates. This is
                a 4x4 grid of floating-point numbers that encodes your camera's position, rotation,
                field of view, and the perspective projection.
            </p>

            <div class="code-block">
                THE VIEW MATRIX STRUCTURE:
                ═════════════════════════════════════════════════════════════════════════════

                // 4x4 Matrix — 16 floats arranged in a grid
                typedef struct {
                float m[4][4]; // m[row][column]
                } Matrix4x4;

                // OR as a flat array (common in game engines):
                typedef struct {
                float m[16]; // Row-major or column-major, depends on engine
                } Matrix4x4_Flat;

                ═════════════════════════════════════════════════════════════════════════════

                VISUAL REPRESENTATION:
                ─────────────────────────────────────────────────────────────────────────────

                ┌ ┐
                │ m[0][0] m[0][1] m[0][2] m[0][3] │
                │ m[1][0] m[1][1] m[1][2] m[1][3] │
                │ m[2][0] m[2][1] m[2][2] m[2][3] │
                │ m[3][0] m[3][1] m[3][2] m[3][3] │
                └ ┘

                This matrix combines:
                1. VIEW MATRIX — Where is the camera? Which way is it looking?
                2. PROJECTION MATRIX — Field of view, aspect ratio, near/far planes

                The combined View-Projection matrix transforms world coordinates
                directly to "clip space" coordinates, which we then convert to pixels.

                ═════════════════════════════════════════════════════════════════════════════

                EXAMPLE VALUES (from a real game):
                ─────────────────────────────────────────────────────────────────────────────

                Matrix4x4 viewMatrix = {
                { 0.8734, 0.0000, 0.4871, -123.45 },
                { 0.1423, 0.9563, -0.2551, 45.67 },
                { -0.4658, 0.2923, 0.8356, -890.12 },
                { 0.0000, 0.0000, 0.0000, 1.00 }
                };

                These numbers change every frame as the camera moves and rotates.
                You must read this matrix from game memory on EVERY frame.

                ═════════════════════════════════════════════════════════════════════════════

                WHERE TO FIND IT:
                ─────────────────────────────────────────────────────────────────────────────

                Common locations (varies by engine):

                - Source Engine (CS:GO, TF2):
                client.dll + 0x4XXXXX → Static pointer to view matrix

                - Unreal Engine:
                Usually in ULocalPlayer or camera manager objects

                - Unity:
                Camera.main.worldToCameraMatrix + Camera.main.projectionMatrix

                Signature scanning or ReClass is typically used to find it.
                Look for 16 consecutive floats that change with camera movement.
            </div>

            <!-- ═══════════════════════════════════════════════════════════════════════
         THE MATH: WORLD TO SCREEN
    ════════════════════════════════════════════════════════════════════════ -->

            <h3>The Math: WorldToScreen Function</h3>

            <p>
                The WorldToScreen function multiplies a 3D position by the view matrix to get
                clip-space coordinates, then performs <strong>perspective division</strong> to get
                normalized device coordinates, and finally scales to screen pixels.
            </p>

            <div class="code-block">
                WORLD TO SCREEN — THE MATHEMATICS:
                ═════════════════════════════════════════════════════════════════════════════

                STEP 1: Matrix Multiplication (3D → Clip Space)
                ─────────────────────────────────────────────────────────────────────────────

                Multiply the 3D point by the view matrix to get clip-space coordinates.

                We treat the 3D point as a 4D vector with W = 1:
                point = (x, y, z, 1)

                Multiplication:
                clipX = x*m[0][0] + y*m[1][0] + z*m[2][0] + m[3][0]
                clipY = x*m[0][1] + y*m[1][1] + z*m[2][1] + m[3][1]
                clipZ = x*m[0][2] + y*m[1][2] + z*m[2][2] + m[3][2] (not always needed)
                clipW = x*m[0][3] + y*m[1][3] + z*m[2][3] + m[3][3]

                ═════════════════════════════════════════════════════════════════════════════

                THE W COMPONENT (Depth):
                ─────────────────────────────────────────────────────────────────────────────

                The W component is CRITICAL. It represents the DEPTH of the point—how far
                away it is from the camera along the view direction.

                W > 0: Point is IN FRONT of the camera (visible)
                W < 0: Point is BEHIND the camera (invisible, DON'T DRAW!) W ≈ 0: Point is at the camera position (edge
                    case) We use W for two things: 1. Checking if the point is visible 2. Perspective division (making
                    far things smaller) ═════════════════════════════════════════════════════════════════════════════
                    STEP 2: The Behind-Camera Check
                    ───────────────────────────────────────────────────────────────────────────── if (clipW < 0.01f) {
                    // Point is BEHIND or AT the camera // DO NOT DRAW — it would appear inverted/wrong return false; }
                    Why 0.01 instead of 0? Floating-point precision. Values very close to zero cause division problems
                    and visual glitches. Using a small threshold like 0.01 prevents artifacts.
                    ═════════════════════════════════════════════════════════════════════════════ STEP 3: Perspective
                    Division (Why Far Things Look Small)
                    ───────────────────────────────────────────────────────────────────────────── Divide X and Y by W to
                    get Normalized Device Coordinates (NDC): ndcX=clipX / clipW ndcY=clipY / clipW This is the MAGIC of
                    perspective projection: - Objects far away have LARGER W values - Dividing by W makes their X/Y
                    coordinates SMALLER - They appear smaller on screen — exactly like real life! Example: Enemy at 10
                    meters: W=10, ndcX=5/10=0.5 Enemy at 100 meters: W=100, ndcX=5/100=0.05 The far enemy's screen
                    position is closer to center — they look smaller.
                    ═════════════════════════════════════════════════════════════════════════════ STEP 4: NDC to Screen
                    Pixels ───────────────────────────────────────────────────────────────────────────── NDC range is
                    typically [-1, 1] for both X and Y: -1=left/bottom edge of screen +1=right/top edge of screen
                    0=center of screen Convert to pixel coordinates: screenX=(screenWidth / 2) * (1.0 + ndcX)
                    screenY=(screenHeight / 2) * (1.0 - ndcY) Note: Y is often inverted because screen coordinates have
                    Y=0 at TOP, but NDC has Y=-1 at bottom, +1 at top. </div>

                    <h4>The Complete WorldToScreen Function in C</h4>

                    <div class="code-block">
                        WORLD TO SCREEN — COMPLETE C IMPLEMENTATION:
                        ═════════════════════════════════════════════════════════════════════════════

                        #include &lt;stdbool.h&gt;

                        // 4x4 Matrix structure
                        typedef struct {
                        float m[4][4];
                        } Matrix4x4;

                        // 2D Screen coordinate
                        typedef struct {
                        float x, y;
                        } Vec2;

                        // 3D World coordinate
                        typedef struct {
                        float x, y, z;
                        } Vec3;

                        /**
                        * WorldToScreen - Convert 3D world position to 2D screen coordinates
                        *
                        * @param pos 3D position in world space
                        * @param viewMatrix The game's view-projection matrix
                        * @param screenWidth Monitor width in pixels (e.g., 1920)
                        * @param screenHeight Monitor height in pixels (e.g., 1080)
                        * @param screenOut Output: 2D screen coordinates
                        *
                        * @return true if point is visible, false if behind camera
                        */
                        bool WorldToScreen(Vec3 pos, Matrix4x4 viewMatrix,
                        int screenWidth, int screenHeight,
                        Vec2 *screenOut) {

                        // ═══════════════════════════════════════════════════════════════════
                        // STEP 1: Matrix Multiplication — Transform to Clip Space
                        // ═══════════════════════════════════════════════════════════════════
                        // Multiply 3D point (with implicit W=1) by the view matrix

                        float clipX = pos.x * viewMatrix.m[0][0] +
                        pos.y * viewMatrix.m[1][0] +
                        pos.z * viewMatrix.m[2][0] +
                        viewMatrix.m[3][0];

                        float clipY = pos.x * viewMatrix.m[0][1] +
                        pos.y * viewMatrix.m[1][1] +
                        pos.z * viewMatrix.m[2][1] +
                        viewMatrix.m[3][1];

                        float clipW = pos.x * viewMatrix.m[0][3] +
                        pos.y * viewMatrix.m[1][3] +
                        pos.z * viewMatrix.m[2][3] +
                        viewMatrix.m[3][3];

                        // ═══════════════════════════════════════════════════════════════════
                        // STEP 2: Behind-Camera Check
                        // ═══════════════════════════════════════════════════════════════════
                        // If W is negative or too small, the point is behind us

                        if (clipW < 0.01f) { // Point is behind the camera — don't draw! return false; } //
                            ═══════════════════════════════════════════════════════════════════ // STEP 3: Perspective
                            Division — Clip Space to NDC //
                            ═══════════════════════════════════════════════════════════════════ // Dividing by W creates
                            the perspective effect // Objects further away (larger W) become smaller on screen float
                            ndcX=clipX / clipW; float ndcY=clipY / clipW; //
                            ═══════════════════════════════════════════════════════════════════ // STEP 4: NDC to Screen
                            Pixels // ═══════════════════════════════════════════════════════════════════ // NDC is in
                            range [-1, 1], convert to [0, screenWidth/Height] // Y is flipped because screen Y=0 is at
                            top, NDC Y=1 is at top screenOut->x = (screenWidth / 2.0f) * (1.0f + ndcX);
                            screenOut->y = (screenHeight / 2.0f) * (1.0f - ndcY);

                            return true; // Point is visible!
                            }

                            ═════════════════════════════════════════════════════════════════════════════

                            EXAMPLE USAGE:
                            ─────────────────────────────────────────────────────────────────────────────

                            // Read view matrix from game memory
                            Matrix4x4 viewMatrix;
                            ReadProcessMemory(hProcess, viewMatrixAddr, &viewMatrix, sizeof(Matrix4x4), NULL);

                            // Enemy head position (from game memory)
                            Vec3 enemyHead = { 1250.5f, 340.2f, 89.0f };

                            // Convert to screen coordinates
                            Vec2 screenPos;
                            if (WorldToScreen(enemyHead, viewMatrix, 1920, 1080, &screenPos)) {
                            // Enemy is visible! Draw ESP box at screenPos.x, screenPos.y
                            DrawESPBox(screenPos.x, screenPos.y, boxWidth, boxHeight);
                            }
                            // If false, enemy is behind us — skip drawing

                            ═════════════════════════════════════════════════════════════════════════════

                            IMPORTANT: MATRIX LAYOUT VARIES!
                            ─────────────────────────────────────────────────────────────────────────────

                            Some games use ROW-MAJOR, some use COLUMN-MAJOR matrices.
                            If your ESP draws in wrong locations, try:

                            1. Swap rows and columns: m[i][j] ↔ m[j][i]
                            2. Negate certain values
                            3. Swap X/Y/Z components

                            Experiment until it works for your specific game.
                    </div>

                    <div class="warn-banner">
                        <strong>The matrix must be fresh:</strong> The view matrix changes every frame as the
                        camera moves. You must read it from game memory on <em>every single frame</em> before
                        calling WorldToScreen. Using a stale matrix will cause ESP boxes to lag behind or
                        appear in wrong locations.
                    </div>

                    <!-- ═══════════════════════════════════════════════════════════════════════
         PART IV: DRAWING THE BOX
    ════════════════════════════════════════════════════════════════════════ -->

                    <h2>Part IV: Drawing the Box</h2>

                    <p>
                        You have screen coordinates. Now you need to draw something visible. The classic
                        ESP box is a rectangle around the enemy, sized appropriately for their distance.
                        Far enemies get small boxes; close enemies get large boxes.
                    </p>

                    <!-- ═══════════════════════════════════════════════════════════════════════
         DISTANCE-BASED SCALING
    ════════════════════════════════════════════════════════════════════════ -->

                    <h3>Distance-Based Box Scaling</h3>

                    <div class="code-block">
                        BOX SIZING BASED ON DISTANCE:
                        ═════════════════════════════════════════════════════════════════════════════

                        THE PROBLEM:
                        ─────────────────────────────────────────────────────────────────────────────

                        If you draw a fixed-size box (e.g., 100x200 pixels), it won't match
                        the apparent size of the enemy:

                        - Close enemy: Box is TOO SMALL, enemy model extends outside
                        - Far enemy: Box is TOO BIG, looks ridiculous

                        We need the box to SCALE with distance, just like the enemy model does.

                        ═════════════════════════════════════════════════════════════════════════════

                        THE SOLUTION: Constant / Distance
                        ─────────────────────────────────────────────────────────────────────────────

                        The apparent size of an object is inversely proportional to distance.

                        FORMULA:
                        boxHeight = CONSTANT / distance
                        boxWidth = boxHeight / ASPECT_RATIO

                        Where:
                        CONSTANT = A magic number tuned to your game (typically 5000-20000)
                        distance = 3D distance from you to the enemy
                        ASPECT_RATIO = height/width ratio of player model (typically ~2.5)

                        ═════════════════════════════════════════════════════════════════════════════

                        C IMPLEMENTATION:
                        ─────────────────────────────────────────────────────────────────────────────

                        #include &lt;math.h&gt;

                        #define BOX_HEIGHT_CONSTANT 10000.0f // Tune for your game!
                        #define PLAYER_ASPECT_RATIO 2.5f // Height / Width ratio

                        typedef struct {
                        float x, y; // Top-left corner (screen coords)
                        float width, height;
                        } ESPBox;

                        /**
                        * CalculateESPBox - Compute an appropriately-sized ESP box
                        *
                        * @param myPos Your 3D position
                        * @param enemyPos Enemy's 3D position (usually feet or center)
                        * @param screenHead 2D screen position of enemy head (from WorldToScreen)
                        * @param screenFeet 2D screen position of enemy feet (from WorldToScreen)
                        *
                        * @return ESPBox with position and dimensions
                        */
                        ESPBox CalculateESPBox(Vec3 myPos, Vec3 enemyPos,
                        Vec2 screenHead, Vec2 screenFeet) {
                        ESPBox box;

                        // Method 1: Use Head-to-Feet distance on screen
                        // More accurate because it uses two actual projected points
                        float screenHeight = screenFeet.y - screenHead.y;
                        float screenWidth = screenHeight / PLAYER_ASPECT_RATIO;

                        box.height = screenHeight;
                        box.width = screenWidth;
                        box.x = screenHead.x - (screenWidth / 2.0f); // Center horizontally
                        box.y = screenHead.y; // Top at head

                        return box;
                        }

                        // ALTERNATIVE: If you only have one point (e.g., center)
                        ESPBox CalculateESPBoxFromDistance(Vec3 myPos, Vec3 enemyPos, Vec2 screenPos) {
                        ESPBox box;

                        // Calculate 3D distance
                        float dx = enemyPos.x - myPos.x;
                        float dy = enemyPos.y - myPos.y;
                        float dz = enemyPos.z - myPos.z;
                        float distance = sqrtf(dx*dx + dy*dy + dz*dz);

                        // Prevent division by zero
                        if (distance < 1.0f) distance=1.0f; // Height is inversely proportional to distance
                            box.height=BOX_HEIGHT_CONSTANT / distance; box.width=box.height / PLAYER_ASPECT_RATIO; //
                            Center the box on the screen position box.x=screenPos.x - (box.width / 2.0f);
                            box.y=screenPos.y - (box.height / 2.0f); return box; }
                            ═════════════════════════════════════════════════════════════════════════════ VISUAL RESULT:
                            ───────────────────────────────────────────────────────────────────────────── ENEMY AT 10
                            METERS: ENEMY AT 100 METERS: ┌─────────────────────┐ ┌───┐ │ │ │ ☠ │ │ ☠ │ └───┘ │ ╱ ╲ │
                            (small box) │ ╱ ╲ │ │ │ │ │ │ │ │ │ │ ╱│ │╲ │ └──╱──┴───────┴──╲────┘ (large box) The box
                            SCALES with the apparent size of the player model. </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         OVERLAY ARCHITECTURE ON LINUX
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>Overlay Architecture on Linux</h3>

                            <p>
                                To draw ESP on Linux, you have two main approaches: <strong>External Overlays</strong>
                                using the display server (X11 or Wayland), or <strong>Internal Rendering</strong> by
                                hooking the game's graphics calls. Each has trade-offs.
                            </p>

                            <div class="code-block">
                                LINUX OVERLAY METHODS:
                                ═════════════════════════════════════════════════════════════════════════════

                                METHOD 1: X11 TRANSPARENT OVERLAY WINDOW (External)
                                ─────────────────────────────────────────────────────────────────────────────

                                Create a transparent, input-passthrough window that sits on top of the game.
                                Draw your ESP on this overlay window.

                                ARCHITECTURE:

                                ┌────────────────────────────────────────────────────────────────┐
                                │ X11 DISPLAY SERVER │
                                │ ┌──────────────────────────────────────────────────────────┐ │
                                │ │ YOUR OVERLAY WINDOW (transparent, always-on-top) │ │
                                │ │ ┌─────┐ │ │
                                │ │ │ ESP │ ← Drawn by YOUR code │ │
                                │ │ └─────┘ │ │
                                │ │ ┌──────────────────────────────────────────────┐ │ │
                                │ │ │ GAME WINDOW │ │ │
                                │ │ │ │ │ │
                                │ │ │ (Game renders here) │ │ │
                                │ │ │ │ │ │
                                │ │ └──────────────────────────────────────────────┘ │ │
                                │ └──────────────────────────────────────────────────────────┘ │
                                └────────────────────────────────────────────────────────────────┘

                                IMPLEMENTATION (X11 + OpenGL):
                                ─────────────────────────────────────────────────────────────────────────────

                                #include &lt;X11/Xlib.h&gt;
                                #include &lt;X11/Xutil.h&gt;
                                #include &lt;X11/extensions/Xfixes.h&gt;
                                #include &lt;X11/extensions/shape.h&gt;
                                #include &lt;GL/glx.h&gt;

                                // Create transparent overlay window
                                Display* display = XOpenDisplay(NULL);
                                int screen = DefaultScreen(display);
                                Window root = RootWindow(display, screen);

                                // Get RGBA visual for transparency
                                XVisualInfo* vi;
                                int attribs[] = { GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_DOUBLEBUFFER, None };
                                vi = glXChooseVisual(display, screen, attribs);

                                // Create colormap for RGBA
                                Colormap cmap = XCreateColormap(display, root, vi->visual, AllocNone);

                                // Window attributes for transparency
                                XSetWindowAttributes swa;
                                swa.colormap = cmap;
                                swa.background_pixel = 0; // Transparent background
                                swa.border_pixel = 0;
                                swa.override_redirect = True; // No window decorations

                                // Create the overlay window (fullscreen)
                                Window overlay = XCreateWindow(
                                display, root,
                                0, 0, 1920, 1080, // Position and size
                                0, // Border width
                                vi->depth, // Depth
                                InputOutput, // Class
                                vi->visual, // Visual
                                CWColormap | CWBackPixel | CWBorderPixel | CWOverrideRedirect,
                                &swa
                                );

                                // Make window click-through (input passthrough)
                                XRectangle rect = { 0, 0, 0, 0 }; // Empty input region
                                XserverRegion region = XFixesCreateRegion(display, &rect, 1);
                                XFixesSetWindowShapeRegion(display, overlay, ShapeInput, 0, 0, region);

                                // Always on top
                                Atom wmState = XInternAtom(display, "_NET_WM_STATE", False);
                                Atom wmAbove = XInternAtom(display, "_NET_WM_STATE_ABOVE", False);
                                XChangeProperty(display, overlay, wmState, XA_ATOM, 32,
                                PropModeReplace, (unsigned char*)&wmAbove, 1);

                                XMapWindow(display, overlay);

                                // Create OpenGL context and draw your ESP here
                                GLXContext ctx = glXCreateContext(display, vi, NULL, True);
                                glXMakeCurrent(display, overlay, ctx);

                                // Main loop: read game memory, WorldToScreen, draw boxes
                                while (running) {
                                glClear(GL_COLOR_BUFFER_BIT);

                                // Draw ESP boxes with OpenGL
                                glColor3f(1.0f, 0.0f, 0.0f); // Red
                                DrawBox(enemyScreenX, enemyScreenY, boxWidth, boxHeight);

                                glXSwapBuffers(display, overlay);
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                PROS:
                                ✓ External — doesn't touch game memory for drawing
                                ✓ Works with any game
                                ✓ Separate process — crash isolation

                                CONS:
                                ✗ Overlay windows are detectable (window enumeration)
                                ✗ Some games use exclusive fullscreen (overlay won't show)
                                ✗ Slight input lag in some configurations
                                ✗ Wayland compositors may block transparent overlays

                                ═════════════════════════════════════════════════════════════════════════════

                                METHOD 2: WAYLAND OVERLAY (More Complex)
                                ─────────────────────────────────────────────────────────────────────────────

                                Wayland is more restrictive than X11. You cannot create arbitrary overlays.

                                Options:
                                1. Use XWayland — Run your overlay as an X11 app on XWayland
                                2. wlr-layer-shell protocol — If compositor supports it (wlroots-based)
                                3. Gamescope — Run game in a nested compositor you control

                                // wlr-layer-shell example (requires compatible compositor)
                                struct zwlr_layer_shell_v1* layer_shell = ...;
                                struct zwlr_layer_surface_v1* layer_surface;

                                layer_surface = zwlr_layer_shell_v1_get_layer_surface(
                                layer_shell,
                                surface,
                                NULL, // Output (NULL = all)
                                ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY, // Top layer
                                "esp_overlay"
                                );

                                Wayland is significantly harder for overlays. Most Linux game hackers
                                use X11 or internal injection instead.

                                ═════════════════════════════════════════════════════════════════════════════

                                METHOD 3: INTERNAL RENDERING HOOKS (Maximum Power)
                                ─────────────────────────────────────────────────────────────────────────────

                                Inject into the game and hook its rendering functions.
                                Draw your ESP directly in the game's render loop.

                                TARGETS:
                                - OpenGL: Hook glXSwapBuffers()
                                - Vulkan: Hook vkQueuePresentKHR()
                                - SDL: Hook SDL_GL_SwapWindow()

                                // Example: Hook glXSwapBuffers
                                typedef void (*glXSwapBuffers_t)(Display*, GLXDrawable);
                                glXSwapBuffers_t original_glXSwapBuffers;

                                void hooked_glXSwapBuffers(Display* dpy, GLXDrawable drawable) {
                                // Draw ESP BEFORE the real swap (appears on screen)
                                DrawAllESPBoxes();

                                // Call original function to present frame
                                original_glXSwapBuffers(dpy, drawable);
                                }

                                // Hook using LD_PRELOAD or inline hooking

                                PROS:
                                ✓ Perfect synchronization with game frames
                                ✓ No overlay window to detect
                                ✓ Works in fullscreen exclusive mode
                                ✓ Can use game's own rendering resources

                                CONS:
                                ✗ Internal — requires injection
                                ✗ More complex to implement
                                ✗ Vulnerable to integrity checks
                            </div>

                            <div class="real-talk">
                                <strong>The choice depends on your threat model:</strong> If the game has no anti-cheat,
                                an X11 overlay is easiest. If there's basic anti-cheat, internal hooks are stealthier.
                                If there's kernel-level anti-cheat, you need kernel-level countermeasures too—but that's
                                beyond the scope of this module.
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         PART V: CHEAT LOGIC (THE ARSENAL)
    ════════════════════════════════════════════════════════════════════════ -->

                            <h2>Part V: Cheat Logic (The Arsenal)</h2>

                            <p>
                                You can read memory. You can write memory. You can inject code. Now we weaponize
                                these capabilities into actual cheat features. Each feature follows the same pattern:
                                find the relevant address, then modify it in a loop, Write once for permanent hacks,
                                write continuously for "locked" hacks.
                            </p>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         GOD MODE
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>God Mode (Infinite Health)</h3>

                            <p>
                                The simplest hack: find the health value and lock it to maximum. Every frame (or on
                                a timer), write your desired health value to the address. The game might reduce it
                                when you take damage, but you immediately overwrite it back.
                            </p>

                            <div class="code-block">
                                GOD MODE — HEALTH LOCKING:
                                ═════════════════════════════════════════════════════════════════════════════

                                THE CONCEPT:
                                ─────────────────────────────────────────────────────────────────────────────

                                Game Logic: Your Hack:
                                ──────────── ──────────
                                take_damage(): while (bGodMode) {
                                player.health -= 50; *health_ptr = MAX_HEALTH;
                                sleep(10ms);
                                }

                                The game reduces health → You immediately write it back → Invincible!

                                ═════════════════════════════════════════════════════════════════════════════

                                FINDING THE HEALTH ADDRESS:
                                ─────────────────────────────────────────────────────────────────────────────

                                Method 1: Cheat Engine / scanmem
                                1. Search for current health (e.g., 100)
                                2. Get damaged, search for new health (e.g., 75)
                                3. Repeat until one address remains
                                4. That's your health address!

                                Method 2: Reverse Engineering
                                1. Find the "take damage" function in IDA/Ghidra
                                2. Trace what memory it modifies
                                3. Calculate offset from player base pointer

                                Typical structure:
                                Player* player = *(Player**)(gameBase + 0x123456);
                                int* health = (int*)((uintptr_t)player + 0xF8);

                                ═════════════════════════════════════════════════════════════════════════════

                                C IMPLEMENTATION (Internal):
                                ─────────────────────────────────────────────────────────────────────────────

                                #include &lt;stdint.h&gt;
                                #include &lt;stdbool.h&gt;
                                #include &lt;unistd.h&gt;

                                // Offsets found via reverse engineering
                                #define OFFSET_PLAYER_PTR 0x123456
                                #define OFFSET_HEALTH 0xF8
                                #define MAX_HEALTH 100

                                // Global toggle
                                bool bGodMode = false;

                                // Called from your hack thread
                                void GodModeLoop(uintptr_t gameBase) {
                                while (1) {
                                if (bGodMode) {
                                // Read player pointer
                                uintptr_t* pPlayerPtr = (uintptr_t*)(gameBase + OFFSET_PLAYER_PTR);
                                uintptr_t player = *pPlayerPtr;

                                if (player != 0) { // Null check!
                                // Get health pointer
                                int* health_ptr = (int*)(player + OFFSET_HEALTH);

                                // Lock health to max
                                *health_ptr = MAX_HEALTH;
                                }
                                }
                                usleep(10000); // 10ms delay (100 times per second)
                                }
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                C IMPLEMENTATION (External — Linux):
                                ─────────────────────────────────────────────────────────────────────────────

                                #define _GNU_SOURCE
                                #include &lt;sys/uio.h&gt;

                                void GodModeExternal(pid_t game_pid, uintptr_t player_addr) {
                                int max_health = MAX_HEALTH;
                                uintptr_t health_addr = player_addr + OFFSET_HEALTH;

                                struct iovec local = { .iov_base = &max_health, .iov_len = sizeof(int) };
                                struct iovec remote = { .iov_base = (void*)health_addr, .iov_len = sizeof(int) };

                                // Write max health
                                process_vm_writev(game_pid, &local, 1, &remote, 1, 0);
                                }
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         INFINITE AMMO
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>Infinite Ammo</h3>

                            <p>
                                Two approaches: continuously write ammo count (like God Mode), or patch the code
                                that decrements ammo so it never runs. The patching approach is cleaner but requires
                                code modification.
                            </p>

                            <div class="code-block">
                                INFINITE AMMO — TWO METHODS:
                                ═════════════════════════════════════════════════════════════════════════════

                                METHOD 1: MEMORY WRITE (Simple)
                                ─────────────────────────────────────────────────────────────────────────────

                                Same as God Mode — find ammo address, write max value continuously.

                                // Offsets
                                #define OFFSET_WEAPON 0x1A0
                                #define OFFSET_AMMO 0x14 // Offset within weapon structure
                                #define MAX_AMMO 999

                                void InfiniteAmmoLoop(uintptr_t player) {
                                while (1) {
                                if (bInfiniteAmmo) {
                                // player -> currentWeapon -> ammo
                                uintptr_t weapon = *(uintptr_t*)(player + OFFSET_WEAPON);
                                if (weapon != 0) {
                                int* ammo_ptr = (int*)(weapon + OFFSET_AMMO);
                                *ammo_ptr = MAX_AMMO;
                                }
                                }
                                usleep(10000);
                                }
                                }

                                PROS: Simple, works externally
                                CONS: Might cause visual glitches (ammo jumps around)

                                ═════════════════════════════════════════════════════════════════════════════

                                METHOD 2: NOP PATCHING (Elegant)
                                ─────────────────────────────────────────────────────────────────────────────

                                Find the instruction that DECREMENTS ammo and replace it with NOPs.
                                The game literally cannot reduce your ammo anymore.

                                BEFORE (Disassembly):
                                ──────────────────────────────────────────────

                                game.exe+0x4A3B20: sub [rdi+0x14], 1 ; Decrement ammo
                                ; Opcode: 83 6F 14 01 (4 bytes)

                                AFTER (Patched):
                                ──────────────────────────────────────────────

                                game.exe+0x4A3B20: nop ; Do nothing
                                nop ; Do nothing
                                nop ; Do nothing
                                nop ; Do nothing
                                ; Opcode: 90 90 90 90 (4 bytes)

                                ═════════════════════════════════════════════════════════════════════════════

                                NOP PATCH C IMPLEMENTATION:
                                ─────────────────────────────────────────────────────────────────────────────

                                #include &lt;sys/mman.h&gt;
                                #include &lt;string.h&gt;

                                #define AMMO_DEC_OFFSET 0x4A3B20 // Address of "sub [rdi+0x14], 1"
                                #define PATCH_SIZE 4

                                // Original bytes (for restoring later)
                                uint8_t originalBytes[PATCH_SIZE] = { 0x83, 0x6F, 0x14, 0x01 };
                                uint8_t nopBytes[PATCH_SIZE] = { 0x90, 0x90, 0x90, 0x90 };

                                void PatchAmmoDecrement(uintptr_t gameBase, bool enable) {
                                uintptr_t patchAddr = gameBase + AMMO_DEC_OFFSET;

                                // Make memory writable (must unprotect .text section)
                                void* pageStart = (void*)(patchAddr & ~0xFFF); // Page-align
                                mprotect(pageStart, 4096, PROT_READ | PROT_WRITE | PROT_EXEC);

                                if (enable) {
                                // Write NOPs
                                memcpy((void*)patchAddr, nopBytes, PATCH_SIZE);
                                } else {
                                // Restore original
                                memcpy((void*)patchAddr, originalBytes, PATCH_SIZE);
                                }

                                // Restore protection
                                mprotect(pageStart, 4096, PROT_READ | PROT_EXEC);
                                }

                                // Usage:
                                if (bInfiniteAmmo && !ammoPatched) {
                                PatchAmmoDecrement(gameBase, true);
                                ammoPatched = true;
                                } else if (!bInfiniteAmmo && ammoPatched) {
                                PatchAmmoDecrement(gameBase, false);
                                ammoPatched = false;
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                NOP PATCH PROS/CONS:
                                ─────────────────────────────────────────────────────────────────────────────

                                PROS:
                                ✓ No continuous writes — patch once, works forever
                                ✓ No visual glitches — ammo stays at current value
                                ✓ Cleaner approach

                                CONS:
                                ✗ Requires finding exact instruction (harder)
                                ✗ Modifies code section — detectable by integrity checks
                                ✗ Only works for internal hacks
                                ✗ Breaks if game updates change instruction location
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         SPEEDHACK
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>Speedhack</h3>

                            <p>
                                Make your player move faster than intended. Two main approaches: modify movement
                                speed constants, or directly manipulate the velocity vector.
                            </p>

                            <div class="code-block">
                                SPEEDHACK — TWO APPROACHES:
                                ═════════════════════════════════════════════════════════════════════════════

                                APPROACH 1: MODIFY WALK SPEED CONSTANT
                                ─────────────────────────────────────────────────────────────────────────────

                                Many games have a float like "fWalkSpeed" or "fMovementSpeed".
                                Find it with Cheat Engine (search for likely values like 250.0, 400.0).
                                Multiply it to go faster.

                                #define OFFSET_WALKSPEED 0x1C4

                                void Speedhack(uintptr_t player, float multiplier) {
                                float* walkSpeed = (float*)(player + OFFSET_WALKSPEED);

                                // Store original on first run
                                static float originalSpeed = 0;
                                if (originalSpeed == 0) {
                                originalSpeed = *walkSpeed;
                                }

                                if (bSpeedhack) {
                                *walkSpeed = originalSpeed * multiplier; // e.g., 2.0x faster
                                } else {
                                *walkSpeed = originalSpeed; // Restore normal
                                }
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                APPROACH 2: MULTIPLY VELOCITY VECTOR
                                ─────────────────────────────────────────────────────────────────────────────

                                Directly scale the player's velocity each frame.
                                Works even if the game has no exposed speed variable.

                                typedef struct {
                                float x, y, z;
                                } Vec3;

                                #define OFFSET_VELOCITY 0x120

                                void VelocitySpeedhack(uintptr_t player, float multiplier) {
                                if (!bSpeedhack) return;

                                Vec3* velocity = (Vec3*)(player + OFFSET_VELOCITY);

                                // Only modify horizontal speed (X and Y), not vertical (Z)
                                // This prevents fall damage exploits in some games
                                velocity->x *= multiplier;
                                velocity->y *= multiplier;
                                // velocity->z *= multiplier; // Uncomment for vertical too
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                CALL EVERY FRAME:
                                ─────────────────────────────────────────────────────────────────────────────

                                // In your main hack loop or render hook
                                void OnFrame() {
                                if (bSpeedhack) {
                                VelocitySpeedhack(localPlayer, speedMultiplier);
                                }
                                }

                                WARNING: The game might cap velocity or detect anomalous speeds.
                                Start with small multipliers (1.2x) to avoid detection.
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         FLY HACK
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>Fly Hack</h3>

                            <p>
                                Make your player fly freely through the air. Typically done by overriding the
                                vertical position (Z or Y coordinate) or disabling gravity calculations.
                            </p>

                            <div class="code-block">
                                FLY HACK — TWO METHODS:
                                ═════════════════════════════════════════════════════════════════════════════

                                METHOD 1: OVERRIDE Z-COORDINATE (Simple)
                                ─────────────────────────────────────────────────────────────────────────────

                                Continuously write the player's vertical position based on keyboard input.
                                Press SPACE to go up, CTRL to go down.

                                #define OFFSET_POSITION 0x100 // Vec3 position within player
                                #define FLY_SPEED 5.0f

                                void FlyHack(uintptr_t player) {
                                if (!bFlyHack) return;

                                Vec3* position = (Vec3*)(player + OFFSET_POSITION);

                                // Check keyboard input (using GetAsyncKeyState on Windows,
                                // or reading /dev/input on Linux)
                                if (IsKeyHeld(KEY_SPACE)) {
                                position->z += FLY_SPEED; // Go up (assuming Z is vertical)
                                }
                                if (IsKeyHeld(KEY_LCTRL)) {
                                position->z -= FLY_SPEED; // Go down
                                }

                                // Optional: Also set velocity.z to 0 to prevent falling
                                Vec3* velocity = (Vec3*)(player + OFFSET_VELOCITY);
                                velocity->z = 0;
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                METHOD 2: DISABLE GRAVITY (NOP Patch)
                                ─────────────────────────────────────────────────────────────────────────────

                                Find and NOP the instruction that applies gravity to the player.
                                Usually something like: velocity.z -= 9.81 * deltaTime

                                BEFORE:
                                ──────────────────────────────────────────────

                                game+0x5A1200: subss xmm0, [gravity_constant] ; Apply gravity
                                movss [rbx+0x128], xmm0 ; Store new Z velocity

                                AFTER (Patched with NOPs):
                                ──────────────────────────────────────────────

                                game+0x5A1200: nop (x8)
                                nop (x5)

                                ═════════════════════════════════════════════════════════════════════════════

                                METHOD 3: SET MOVETYPE TO NOCLIP
                                ─────────────────────────────────────────────────────────────────────────────

                                Many engines (Source, idTech) have a "MoveType" enum.
                                Setting it to MOVETYPE_NOCLIP enables flying through walls.

                                enum MoveType {
                                MOVETYPE_WALK = 0,
                                MOVETYPE_FLY = 1,
                                MOVETYPE_NOCLIP = 2,
                                // ...
                                };

                                #define OFFSET_MOVETYPE 0x1E8

                                void NoClip(uintptr_t player, bool enable) {
                                uint8_t* moveType = (uint8_t*)(player + OFFSET_MOVETYPE);

                                if (enable) {
                                *moveType = MOVETYPE_NOCLIP;
                                } else {
                                *moveType = MOVETYPE_WALK;
                                }
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                COMPLETE FLY IMPLEMENTATION:
                                ─────────────────────────────────────────────────────────────────────────────

                                void ProcessFlyHack(uintptr_t player) {
                                static bool wasEnabled = false;

                                Vec3* pos = (Vec3*)(player + OFFSET_POSITION);
                                Vec3* vel = (Vec3*)(player + OFFSET_VELOCITY);

                                if (bFlyHack) {
                                // Zero out velocity so we have full control
                                vel->x = 0;
                                vel->y = 0;
                                vel->z = 0;

                                // WASD for horizontal, Space/Ctrl for vertical
                                if (IsKeyHeld(KEY_W)) pos->y += FLY_SPEED; // Forward
                                if (IsKeyHeld(KEY_S)) pos->y -= FLY_SPEED; // Backward
                                if (IsKeyHeld(KEY_A)) pos->x -= FLY_SPEED; // Left
                                if (IsKeyHeld(KEY_D)) pos->x += FLY_SPEED; // Right
                                if (IsKeyHeld(KEY_SPACE)) pos->z += FLY_SPEED; // Up
                                if (IsKeyHeld(KEY_LCTRL)) pos->z -= FLY_SPEED; // Down

                                wasEnabled = true;
                                } else if (wasEnabled) {
                                // Restore normal gravity when disabled
                                wasEnabled = false;
                                }
                                }
                            </div>

                            <div class="warn-banner">
                                <strong>Server-side validation:</strong> Many online games validate player positions
                                server-side. Flying to impossible locations will result in rubber-banding (server
                                forcing you back) or an instant ban. These techniques work best on single-player
                                games or games with client-authoritative movement.
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         PART VI: THE MOD MENU (HOOKING)
    ════════════════════════════════════════════════════════════════════════ -->

                            <h2>Part VI: The Mod Menu (Hooking)</h2>

                            <p>
                                A proper cheat needs a user interface—a "mod menu" to toggle features on and off.
                                This requires hooking the game's render function to draw our menu, and intercepting
                                input to control it.
                            </p>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         THE RENDER HOOK
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>The Hook: Intercepting Render Functions</h3>

                            <p>
                                To draw a menu inside the game, we hook the function that presents each frame
                                to the screen. Our hook draws the menu, then calls the original function.
                            </p>

                            <div class="code-block">
                                RENDER HOOK ARCHITECTURE:
                                ═════════════════════════════════════════════════════════════════════════════

                                NORMAL GAME FLOW:
                                ─────────────────────────────────────────────────────────────────────────────

                                Game Loop:
                                1. Update game logic
                                2. Render 3D scene
                                3. Render UI (HUD)
                                4. Call SDL_GL_SwapBuffers() or Present() to display frame
                                5. Repeat

                                ═════════════════════════════════════════════════════════════════════════════

                                HOOKED FLOW:
                                ─────────────────────────────────────────────────────────────────────────────

                                Game Loop:
                                1. Update game logic
                                2. Render 3D scene
                                3. Render UI (HUD)
                                4. Call SDL_GL_SwapBuffers() → REDIRECTED to our hook!
                                ↓
                                ┌─────────────────────────────────────────────────────────────────┐
                                │ OUR HOOK: │
                                │ 1. Draw ESP boxes │
                                │ 2. Draw mod menu │
                                │ 3. Process cheat logic (god mode, aimbot, etc.) │
                                │ 4. Call ORIGINAL SDL_GL_SwapBuffers() to display frame │
                                └─────────────────────────────────────────────────────────────────┘
                                5. Repeat

                                ═════════════════════════════════════════════════════════════════════════════

                                LINUX — HOOKING SDL_GL_SwapWindow:
                                ─────────────────────────────────────────────────────────────────────────────

                                Two methods: LD_PRELOAD or inline hook

                                // METHOD 1: LD_PRELOAD (easiest)
                                // Save as: hook.c, compile: gcc -shared -fPIC -o hook.so hook.c -ldl
                                // Run: LD_PRELOAD=./hook.so ./game

                                #define _GNU_SOURCE
                                #include &lt;SDL2/SDL.h&gt;
                                #include &lt;dlfcn.h&gt;

                                // Pointer to original function
                                void (*original_SDL_GL_SwapWindow)(SDL_Window*) = NULL;

                                void SDL_GL_SwapWindow(SDL_Window* window) {
                                // Load original on first call
                                if (!original_SDL_GL_SwapWindow) {
                                original_SDL_GL_SwapWindow = dlsym(RTLD_NEXT, "SDL_GL_SwapWindow");
                                }

                                // ═══════════════════════════════════════════════════════════════
                                // OUR CODE RUNS HERE — EVERY FRAME!
                                // ═══════════════════════════════════════════════════════════════

                                // Process cheats
                                if (bGodMode) GodMode();
                                if (bAimbot) Aimbot();
                                if (bESP) DrawESP();

                                // Draw mod menu
                                if (bMenuOpen) DrawModMenu();

                                // ═══════════════════════════════════════════════════════════════

                                // Call original to actually display the frame
                                original_SDL_GL_SwapWindow(window);
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                DIRECTX 9/11 — HOOKING Present (Windows):
                                ─────────────────────────────────────────────────────────────────────────────

                                // DirectX 9: Hook IDirect3DDevice9::Present
                                // DirectX 11: Hook IDXGISwapChain::Present

                                typedef HRESULT (STDMETHODCALLTYPE* Present_t)(
                                IDXGISwapChain* pSwapChain,
                                UINT SyncInterval,
                                UINT Flags
                                );

                                Present_t originalPresent = NULL;

                                HRESULT STDMETHODCALLTYPE HookedPresent(
                                IDXGISwapChain* pSwapChain,
                                UINT SyncInterval,
                                UINT Flags
                                ) {
                                // Draw menu and ESP here
                                if (bMenuOpen) DrawModMenu();
                                if (bESP) DrawESP();

                                // Call original
                                return originalPresent(pSwapChain, SyncInterval, Flags);
                                }

                                // Hook by modifying the VTable or using Detours/MinHook
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         THE GUI: DRAWING THE MENU
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>The GUI: Drawing the Menu</h3>

                            <p>
                                Use a minimal immediate-mode GUI library to draw checkboxes, sliders, and buttons.
                                <strong>Nuklear</strong> and <strong>Dear ImGui</strong> are popular choices for
                                game hacking because they're lightweight and render directly via OpenGL/DirectX.
                            </p>

                            <div class="code-block">
                                MOD MENU GUI — USING NUKLEAR:
                                ═════════════════════════════════════════════════════════════════════════════

                                SETUP (in your hook):
                                ─────────────────────────────────────────────────────────────────────────────

                                #define NK_INCLUDE_FIXED_TYPES
                                #define NK_INCLUDE_DEFAULT_ALLOCATOR
                                #define NK_IMPLEMENTATION
                                #include "nuklear.h"

                                // Initialize once
                                struct nk_context* ctx = NULL;

                                void InitMenu() {
                                ctx = nk_create_context(...); // See Nuklear docs
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                DRAW MENU (every frame when menu is open):
                                ─────────────────────────────────────────────────────────────────────────────

                                void DrawModMenu() {
                                if (nk_begin(ctx, "Mod Menu", nk_rect(50, 50, 300, 400),
                                NK_WINDOW_BORDER | NK_WINDOW_MOVABLE | NK_WINDOW_TITLE))
                                {
                                // ═══════════════════════════════════════════════════════════
                                // AIMBOT SECTION
                                // ═══════════════════════════════════════════════════════════
                                nk_layout_row_dynamic(ctx, 30, 1);
                                nk_label(ctx, "=== AIMBOT ===", NK_TEXT_CENTERED);

                                nk_checkbox_label(ctx, "Enable Aimbot", &bAimbot);
                                nk_checkbox_label(ctx, "Silent Aim", &bSilentAim);

                                nk_label(ctx, "FOV:", NK_TEXT_LEFT);
                                nk_slider_float(ctx, 1.0f, &aimFOV, 180.0f, 1.0f);

                                nk_label(ctx, "Smoothing:", NK_TEXT_LEFT);
                                nk_slider_float(ctx, 1.0f, &aimSmooth, 20.0f, 0.5f);

                                // ═══════════════════════════════════════════════════════════
                                // ESP SECTION
                                // ═══════════════════════════════════════════════════════════
                                nk_layout_row_dynamic(ctx, 30, 1);
                                nk_label(ctx, "=== ESP ===", NK_TEXT_CENTERED);

                                nk_checkbox_label(ctx, "Enable ESP", &bESP);
                                nk_checkbox_label(ctx, "Box ESP", &bBoxESP);
                                nk_checkbox_label(ctx, "Health Bar", &bHealthBar);
                                nk_checkbox_label(ctx, "Name Tags", &bNameTags);
                                nk_checkbox_label(ctx, "Distance", &bDistance);

                                // ═══════════════════════════════════════════════════════════
                                // MISC SECTION
                                // ═══════════════════════════════════════════════════════════
                                nk_layout_row_dynamic(ctx, 30, 1);
                                nk_label(ctx, "=== MISC ===", NK_TEXT_CENTERED);

                                nk_checkbox_label(ctx, "God Mode", &bGodMode);
                                nk_checkbox_label(ctx, "Infinite Ammo", &bInfiniteAmmo);
                                nk_checkbox_label(ctx, "Speedhack", &bSpeedhack);
                                nk_checkbox_label(ctx, "Fly Hack", &bFlyHack);

                                if (bSpeedhack) {
                                nk_label(ctx, "Speed Multiplier:", NK_TEXT_LEFT);
                                nk_slider_float(ctx, 1.0f, &speedMultiplier, 5.0f, 0.1f);
                                }
                                }
                                nk_end(ctx);

                                // Render the UI
                                nk_render(ctx, ...); // Draw commands to OpenGL
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                TOGGLE MENU WITH KEY (e.g., INSERT):
                                ─────────────────────────────────────────────────────────────────────────────

                                // Check once per frame, toggle on key press
                                static bool lastKeyState = false;
                                bool currentKeyState = IsKeyDown(KEY_INSERT);

                                if (currentKeyState && !lastKeyState) {
                                bMenuOpen = !bMenuOpen; // Toggle
                                }
                                lastKeyState = currentKeyState;
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         INPUT HIJACKING
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>Input Hijacking: Blocking Game Input When Menu is Open</h3>

                            <p>
                                When your menu is visible, mouse clicks should control the menu—not fire weapons
                                or move the camera. You must intercept input events and consume them when the
                                menu is open.
                            </p>

                            <div class="code-block">
                                INPUT HIJACKING:
                                ═════════════════════════════════════════════════════════════════════════════

                                THE PROBLEM:
                                ─────────────────────────────────────────────────────────────────────────────

                                Without input hijacking:

                                1. User opens menu (INSERT key)
                                2. User clicks "Enable Aimbot" checkbox
                                3. Click ALSO fires weapon in game!
                                4. User moves mouse to slider
                                5. Camera ALSO spins around in game!

                                We need to INTERCEPT input when menu is open.

                                ═════════════════════════════════════════════════════════════════════════════

                                LINUX — HOOK SDL_PollEvent:
                                ─────────────────────────────────────────────────────────────────────────────

                                int (*original_SDL_PollEvent)(SDL_Event*) = NULL;

                                int SDL_PollEvent(SDL_Event* event) {
                                if (!original_SDL_PollEvent) {
                                original_SDL_PollEvent = dlsym(RTLD_NEXT, "SDL_PollEvent");
                                }

                                int result = original_SDL_PollEvent(event);

                                if (result && bMenuOpen) {
                                // Menu is open — check if we should consume this event

                                switch (event->type) {
                                case SDL_MOUSEMOTION:
                                case SDL_MOUSEBUTTONDOWN:
                                case SDL_MOUSEBUTTONUP:
                                case SDL_MOUSEWHEEL:
                                // Feed to our menu GUI
                                nk_input_motion(ctx, event->motion.x, event->motion.y);
                                // etc...

                                // Return 0 to tell game "no event happened"
                                return 0;

                                case SDL_KEYDOWN:
                                case SDL_KEYUP:
                                // Let INSERT through (to close menu)
                                if (event->key.keysym.sym == SDLK_INSERT) {
                                break;
                                }
                                // Block other keys while menu open
                                return 0;
                                }
                                }

                                return result;
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                WINDOWS — HOOK GetAsyncKeyState FOR MOUSE:
                                ─────────────────────────────────────────────────────────────────────────────

                                SHORT WINAPI HookedGetAsyncKeyState(int vKey) {
                                // If menu open and this is a mouse button, return "not pressed"
                                if (bMenuOpen) {
                                if (vKey == VK_LBUTTON || vKey == VK_RBUTTON || vKey == VK_MBUTTON) {
                                // Feed to our GUI first
                                ProcessMouseForMenu(vKey);
                                // Return "not pressed" to game
                                return 0;
                                }
                                }

                                return originalGetAsyncKeyState(vKey);
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                WNDPROC HOOK (Windows — More Complete):
                                ─────────────────────────────────────────────────────────────────────────────

                                LRESULT CALLBACK HookedWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
                                if (bMenuOpen) {
                                // Feed all input to ImGui/Nuklear first
                                if (ImGui_ImplWin32_WndProcHandler(hwnd, msg, wParam, lParam)) {
                                // ImGui consumed this event — don't pass to game
                                return true;
                                }

                                // Block all mouse/keyboard messages from reaching game
                                switch (msg) {
                                case WM_LBUTTONDOWN:
                                case WM_LBUTTONUP:
                                case WM_RBUTTONDOWN:
                                case WM_RBUTTONUP:
                                case WM_MOUSEMOVE:
                                case WM_MOUSEWHEEL:
                                case WM_KEYDOWN:
                                case WM_KEYUP:
                                return 0; // Don't pass to original WndProc
                                }
                                }

                                return CallWindowProc(originalWndProc, hwnd, msg, wParam, lParam);
                                }

                                ═════════════════════════════════════════════════════════════════════════════

                                THE RESULT:
                                ─────────────────────────────────────────────────────────────────────────────

                                ┌────────────────────────────────────────────────────────────────────┐
                                │ GAME SCREEN │
                                │ │
                                │ ┌──────────────────────────┐ │
                                │ │ MOD MENU │ ← Mouse clicks work HERE │
                                │ │ [ ] Enable Aimbot │ │
                                │ │ [X] Enable ESP │ │
                                │ │ [ ] God Mode │ │
                                │ │ Speed: ████░░░░ 2.5x │ │
                                │ └──────────────────────────┘ │
                                │ │
                                │ ← Mouse clicks BLOCKED here │
                                │ (game doesn't receive input) │
                                └────────────────────────────────────────────────────────────────────┘

                                Press INSERT again to close menu and resume normal game input.
                            </div>

                            <div class="real-talk">
                                <strong>The complete picture:</strong> A polished internal cheat combines all of these
                                elements: render hook for drawing, input hook for menu control, memory read/write for
                                cheats, and a clean GUI for configuration. Each component builds on the last. Master
                                them individually, then combine them into your framework.
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         PART VII: THE FINAL PROJECT — ASSAULTCUBE PROFESSIONAL MOD MENU
    ════════════════════════════════════════════════════════════════════════ -->

                            <h2>Part VII: The Final Project — AssaultCube Professional Mod Menu</h2>

                            <p>
                                Theory is worthless without practice. In this final section, we build a complete,
                                production-quality mod menu for <strong>AssaultCube</strong>—an open-source FPS that
                                runs natively on Linux, uses SDL/OpenGL, and is lightweight enough for any hardware.
                                This is not a toy script. This is professional-grade software architecture.
                            </p>

                            <div class="real-talk">
                                <strong>Why AssaultCube?</strong><br>
                                ✓ <strong>Open Source</strong> — Full source code available, offsets verifiable<br>
                                ✓ <strong>Native Linux</strong> — No Wine/Proton needed<br>
                                ✓ <strong>Lightweight</strong> — Runs on any laptop from the last 15 years<br>
                                ✓ <strong>SDL + OpenGL</strong> — Standard libraries we can hook cleanly<br>
                                ✓ <strong>Active</strong> — Still maintained and playable<br><br>
                                Install: <code>sudo pacman -S assaultcube</code> (Arch) or build from source.
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         RECONNAISSANCE
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>Phase I: Reconnaissance — Finding Offsets</h3>

                            <p>
                                Before writing code, we need addresses. AssaultCube is open source, so we can read
                                the actual game code to find structures. For closed-source games, you'd use
                                reverse engineering tools like Ghidra, IDA, or ReClass.
                            </p>

                            <div class="code-block">
                                ASSAULTCUBE RECONNAISSANCE:
                                ═════════════════════════════════════════════════════════════════════════════

                                STEP 1: GET THE SOURCE CODE
                                ─────────────────────────────────────────────────────────────────────────────

                                $ git clone https://github.com/assaultcube/AC.git
                                $ cd AC/source/src

                                Key files to examine:
                                - entity.h → Player/Entity structures
                                - physics.cpp → Movement and position
                                - weapon.h → Weapon/ammo structures
                                - rendergl.cpp → View matrix and rendering

                                ═════════════════════════════════════════════════════════════════════════════

                                STEP 2: FIND THE PLAYER STRUCTURE
                                ─────────────────────────────────────────────────────────────────────────────

                                From entity.h (simplified):

                                struct playerent : dynent {
                                int health, armour; // Offset: varies by build
                                int primary, nextprimary;
                                int gunselect;
                                bool attacking;
                                // ... more fields
                                vec o; // Position (origin)
                                vec vel; // Velocity
                                float yaw, pitch, roll; // View angles
                                };

                                The local player pointer is typically:
                                playerent* player1 = ... // Global pointer in game

                                ═════════════════════════════════════════════════════════════════════════════

                                STEP 3: FIND OFFSETS DYNAMICALLY (Runtime Method)
                                ─────────────────────────────────────────────────────────────────────────────

                                If offsets change between versions, use signature scanning:

                                // Signature for player health access
                                // Look for: mov eax, [edi+0x??] (where ?? is health offset)

                                Or use scanmem/GameConqueror:
                                1. Start game, note health (100)
                                2. $ scanmem
                                3. Search: 100
                                4. Take damage, search new value
                                5. Repeat until one address remains
                                6. Calculate offset from player1 base

                                ═════════════════════════════════════════════════════════════════════════════

                                ASSAULTCUBE 1.3.0.2 OFFSETS (Verify for your version!):
                                ─────────────────────────────────────────────────────────────────────────────

                                // These offsets are for educational reference
                                // You MUST verify for your specific build!

                                #define OFFSET_HEALTH 0xF8
                                #define OFFSET_ARMOUR 0xFC
                                #define OFFSET_AMMO 0x150 // Current weapon ammo
                                #define OFFSET_MAG 0x13C // Magazine/clip ammo
                                #define OFFSET_POSITION 0x4 // vec o (x,y,z position)
                                #define OFFSET_VIEWANGLES 0x40 // yaw, pitch
                                #define OFFSET_TEAM 0x32C
                                #define OFFSET_NAME 0x225

                                // Entity list: array of playerent* for all players
                                // View matrix: 16 floats updated each frame
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         PROJECT STRUCTURE
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>Phase II: Project Architecture</h3>

                            <p>
                                Real cheats aren't single-file hacks. They're modular, maintainable codebases.
                                Here's our project structure:
                            </p>

                            <div class="code-block">
                                PROJECT STRUCTURE:
                                ═════════════════════════════════════════════════════════════════════════════

                                assaultcube-mod/
                                ├── Makefile # Build system
                                ├── include/
                                │ ├── game.h # Game structures and offsets
                                │ ├── config.h # Cheat configuration/globals
                                │ ├── hooks.h # Hook function declarations
                                │ └── draw.h # OpenGL drawing helpers
                                └── src/
                                ├── main.c # Entry point, hook installation
                                ├── hooks.c # SDL_GL_SwapWindow hook
                                ├── cheats.c # God mode, infinite ammo, etc.
                                ├── esp.c # ESP drawing logic
                                ├── menu.c # Mod menu GUI
                                └── draw.c # OpenGL primitives

                                ═════════════════════════════════════════════════════════════════════════════
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         INCLUDE/GAME.H
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>File: include/game.h</h3>

                            <div class="code-block">
                                /*
                                * game.h — AssaultCube Game Structures and Offsets
                                *
                                * Reverse-engineered structures matching the game's internal layout.
                                * Offsets verified against AssaultCube source code.
                                */

                                #ifndef GAME_H
                                #define GAME_H

                                #include &lt;stdint.h&gt;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * VECTOR TYPES
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                typedef struct {
                                float x, y, z;
                                } vec3_t;

                                typedef struct {
                                float x, y;
                                } vec2_t;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * PLAYER STRUCTURE
                                * Simplified version of playerent from AssaultCube source
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                typedef struct {
                                vec3_t position; // Offset 0x04: World position (o)
                                vec3_t velocity; // Offset 0x10: Movement velocity
                                float yaw; // Offset 0x40: Horizontal view angle
                                float pitch; // Offset 0x44: Vertical view angle
                                float roll; // Offset 0x48: Roll (usually 0)

                                // Padding to reach health offset
                                char _pad1[0xAC]; // Padding

                                int health; // Offset 0xF8
                                int armour; // Offset 0xFC

                                char _pad2[0x3C]; // Padding

                                int magazine[8]; // Offset 0x13C: Ammo in current clip per weapon
                                int ammo[8]; // Offset 0x15C: Reserve ammo per weapon

                                char _pad3[0xA5]; // Padding

                                char name[16]; // Offset 0x225: Player name

                                char _pad4[0xFB]; // Padding

                                int team; // Offset 0x32C: 0=CLA, 1=RVSF
                                } player_t;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * OFFSET DEFINITIONS (Verify for your build!)
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                // These are typical offsets — may vary between versions!
                                #define OFF_POSITION 0x04
                                #define OFF_VELOCITY 0x10
                                #define OFF_YAW 0x40
                                #define OFF_PITCH 0x44
                                #define OFF_HEALTH 0xF8
                                #define OFF_ARMOUR 0xFC
                                #define OFF_MAGAZINE 0x13C
                                #define OFF_AMMO 0x15C
                                #define OFF_NAME 0x225
                                #define OFF_TEAM 0x32C

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * GAME POINTERS
                                * Found via signature scanning or static analysis
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                // Module name for pattern scanning
                                #define GAME_MODULE "native_client"

                                // These are example patterns — you must find real ones!
                                // Pattern: player1 pointer access
                                // Pattern: entity list access
                                // Pattern: view matrix access

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * HELPER MACROS
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                #define READ_FIELD(base, offset, type) \
                                (*(type*)((uintptr_t)(base) + (offset)))

                                #define WRITE_FIELD(base, offset, type, value) \
                                (*(type*)((uintptr_t)(base) + (offset)) = (value))

                                #endif /* GAME_H */
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         INCLUDE/CONFIG.H
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>File: include/config.h</h3>

                            <div class="code-block">
                                /*
                                * config.h — Global Configuration and State
                                */

                                #ifndef CONFIG_H
                                #define CONFIG_H

                                #include &lt;stdbool.h&gt;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * CHEAT TOGGLES
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                typedef struct {
                                // Menu state
                                bool menu_open;

                                // Combat
                                bool god_mode;
                                bool infinite_ammo;
                                bool no_recoil;

                                // Visuals
                                bool esp_enabled;
                                bool esp_box;
                                bool esp_health;
                                bool esp_name;
                                bool esp_distance;
                                bool esp_team_check; // Don't show teammates

                                // Movement
                                bool speed_hack;
                                float speed_multiplier;
                                bool fly_hack;

                                } cheat_config_t;

                                /* Global configuration instance */
                                extern cheat_config_t g_config;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * GAME STATE
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                typedef struct {
                                // Pointers discovered at runtime
                                uintptr_t player1; // Local player pointer
                                uintptr_t entity_list; // Array of player pointers
                                uintptr_t view_matrix; // 4x4 view-projection matrix
                                int num_players; // Current player count

                                // Screen dimensions
                                int screen_width;
                                int screen_height;

                                // Module base (for offset calculations)
                                uintptr_t module_base;

                                } game_state_t;

                                /* Global game state instance */
                                extern game_state_t g_game;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * INITIALIZATION
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                void config_init(void);
                                void game_state_init(void);

                                #endif /* CONFIG_H */
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         INCLUDE/DRAW.H
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>File: include/draw.h</h3>

                            <div class="code-block">
                                /*
                                * draw.h — OpenGL Drawing Helpers
                                */

                                #ifndef DRAW_H
                                #define DRAW_H

                                #include &lt;stdbool.h&gt;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * COLOR DEFINITIONS
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                typedef struct {
                                float r, g, b, a;
                                } color_t;

                                #define COLOR_RED (color_t){1.0f, 0.0f, 0.0f, 1.0f}
                                #define COLOR_GREEN (color_t){0.0f, 1.0f, 0.0f, 1.0f}
                                #define COLOR_BLUE (color_t){0.0f, 0.0f, 1.0f, 1.0f}
                                #define COLOR_YELLOW (color_t){1.0f, 1.0f, 0.0f, 1.0f}
                                #define COLOR_WHITE (color_t){1.0f, 1.0f, 1.0f, 1.0f}
                                #define COLOR_BLACK (color_t){0.0f, 0.0f, 0.0f, 1.0f}
                                #define COLOR_ENEMY (color_t){1.0f, 0.2f, 0.2f, 1.0f}
                                #define COLOR_TEAM (color_t){0.2f, 1.0f, 0.2f, 1.0f}

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * DRAWING FUNCTIONS
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                /* Initialize OpenGL state for 2D drawing */
                                void draw_begin_2d(int screen_w, int screen_h);

                                /* Restore OpenGL state after 2D drawing */
                                void draw_end_2d(void);

                                /* Draw a rectangle outline */
                                void draw_rect(float x, float y, float w, float h, color_t color, float thickness);

                                /* Draw a filled rectangle */
                                void draw_rect_filled(float x, float y, float w, float h, color_t color);

                                /* Draw a line */
                                void draw_line(float x1, float y1, float x2, float y2, color_t color, float thickness);

                                /* Draw a health bar (filled portion based on percentage) */
                                void draw_health_bar(float x, float y, float w, float h, int health, int max_health);

                                /* Draw text (basic bitmap font) */
                                void draw_text(float x, float y, const char* text, color_t color);

                                #endif /* DRAW_H */
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         SRC/DRAW.C
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>File: src/draw.c</h3>

                            <div class="code-block">
                                /*
                                * draw.c — OpenGL 1.x Drawing Implementation
                                *
                                * Uses legacy OpenGL for maximum compatibility with older games.
                                */

                                #include "draw.h"
                                #include &lt;GL/gl.h&gt;
                                #include &lt;string.h&gt;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * 2D MODE SETUP
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                static GLint viewport[4];
                                static GLdouble projection[16];
                                static GLdouble modelview[16];

                                void draw_begin_2d(int screen_w, int screen_h) {
                                /* Save current state */
                                glGetIntegerv(GL_VIEWPORT, viewport);
                                glGetDoublev(GL_PROJECTION_MATRIX, projection);
                                glGetDoublev(GL_MODELVIEW_MATRIX, modelview);

                                /* Disable 3D features */
                                glDisable(GL_DEPTH_TEST);
                                glDisable(GL_TEXTURE_2D);
                                glDisable(GL_LIGHTING);
                                glEnable(GL_BLEND);
                                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

                                /* Set up orthographic projection for 2D */
                                glMatrixMode(GL_PROJECTION);
                                glPushMatrix();
                                glLoadIdentity();
                                glOrtho(0, screen_w, screen_h, 0, -1, 1);

                                glMatrixMode(GL_MODELVIEW);
                                glPushMatrix();
                                glLoadIdentity();
                                }

                                void draw_end_2d(void) {
                                /* Restore matrices */
                                glMatrixMode(GL_PROJECTION);
                                glPopMatrix();

                                glMatrixMode(GL_MODELVIEW);
                                glPopMatrix();

                                /* Re-enable 3D features */
                                glEnable(GL_DEPTH_TEST);
                                glEnable(GL_TEXTURE_2D);
                                glDisable(GL_BLEND);
                                }

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * PRIMITIVE DRAWING
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                void draw_rect(float x, float y, float w, float h, color_t color, float thickness) {
                                glLineWidth(thickness);
                                glColor4f(color.r, color.g, color.b, color.a);

                                glBegin(GL_LINE_LOOP);
                                glVertex2f(x, y);
                                glVertex2f(x + w, y);
                                glVertex2f(x + w, y + h);
                                glVertex2f(x, y + h);
                                glEnd();
                                }

                                void draw_rect_filled(float x, float y, float w, float h, color_t color) {
                                glColor4f(color.r, color.g, color.b, color.a);

                                glBegin(GL_QUADS);
                                glVertex2f(x, y);
                                glVertex2f(x + w, y);
                                glVertex2f(x + w, y + h);
                                glVertex2f(x, y + h);
                                glEnd();
                                }

                                void draw_line(float x1, float y1, float x2, float y2, color_t color, float thickness) {
                                glLineWidth(thickness);
                                glColor4f(color.r, color.g, color.b, color.a);

                                glBegin(GL_LINES);
                                glVertex2f(x1, y1);
                                glVertex2f(x2, y2);
                                glEnd();
                                }

                                void draw_health_bar(float x, float y, float w, float h, int health, int max_health) {
                                float pct = (float)health / (float)max_health;
                                if (pct < 0) pct=0; if (pct> 1) pct = 1;

                                    /* Background (black) */
                                    draw_rect_filled(x, y, w, h, (color_t){0.1f, 0.1f, 0.1f, 0.8f});

                                    /* Health portion (green to red gradient) */
                                    color_t health_color = {1.0f - pct, pct, 0.0f, 1.0f};
                                    draw_rect_filled(x, y, w * pct, h, health_color);

                                    /* Border */
                                    draw_rect(x, y, w, h, COLOR_BLACK, 1.0f);
                                    }

                                    /* ═══════════════════════════════════════════════════════════════════════════
                                    * TEXT DRAWING (Simple Implementation)
                                    * ═══════════════════════════════════════════════════════════════════════════ */

                                    /* For a real implementation, use bitmap fonts or FreeType */
                                    void draw_text(float x, float y, const char* text, color_t color) {
                                    /* Placeholder — in production, implement bitmap font rendering */
                                    /* For now, we skip text. You can integrate stb_truetype or glutBitmapCharacter */
                                    (void)x; (void)y; (void)text; (void)color;
                                    }
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         SRC/CHEATS.C
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>File: src/cheats.c</h3>

                            <div class="code-block">
                                /*
                                * cheats.c — Cheat Feature Implementations
                                */

                                #include "config.h"
                                #include "game.h"
                                #include &lt;stdio.h&gt;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * GOD MODE
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                void cheat_god_mode(void) {
                                if (!g_config.god_mode) return;
                                if (!g_game.player1) return;

                                /* Lock health to maximum */
                                int* health = (int*)(g_game.player1 + OFF_HEALTH);
                                int* armour = (int*)(g_game.player1 + OFF_ARMOUR);

                                *health = 100;
                                *armour = 100;
                                }

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * INFINITE AMMO
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                void cheat_infinite_ammo(void) {
                                if (!g_config.infinite_ammo) return;
                                if (!g_game.player1) return;

                                /* Fill all weapon magazines and reserves */
                                int* magazine = (int*)(g_game.player1 + OFF_MAGAZINE);
                                int* ammo = (int*)(g_game.player1 + OFF_AMMO);

                                for (int i = 0; i < 8; i++) { magazine[i]=999; ammo[i]=999; } } /*
                                    ═══════════════════════════════════════════════════════════════════════════ * SPEED
                                    HACK * ═══════════════════════════════════════════════════════════════════════════
                                    */ void cheat_speed_hack(void) { if (!g_config.speed_hack) return; if
                                    (!g_game.player1) return; /* Note: This is a simple approach. More robust would be
                                    to * patch the movement speed constant or hook physics. */ vec3_t*
                                    velocity=(vec3_t*)(g_game.player1 + OFF_VELOCITY); float
                                    mult=g_config.speed_multiplier; if (mult <=1.0f) return; /* Scale horizontal
                                    velocity only */ velocity->x *= mult;
                                    velocity->y *= mult;
                                    }

                                    /* ═══════════════════════════════════════════════════════════════════════════
                                    * MAIN CHEAT LOOP — Called every frame
                                    * ═══════════════════════════════════════════════════════════════════════════ */

                                    void process_cheats(void) {
                                    cheat_god_mode();
                                    cheat_infinite_ammo();
                                    cheat_speed_hack();
                                    }
                            </div>

                            <!-- ═══════════════════════════════════════════════════════════════════════
         SRC/ESP.C
    ════════════════════════════════════════════════════════════════════════ -->

                            <h3>File: src/esp.c</h3>

                            <div class="code-block">
                                /*
                                * esp.c — Extra Sensory Perception (Wallhack Visuals)
                                */

                                #include "config.h"
                                #include "game.h"
                                #include "draw.h"
                                #include &lt;math.h&gt;
                                #include &lt;string.h&gt;

                                /* ═══════════════════════════════════════════════════════════════════════════
                                * WORLD TO SCREEN CONVERSION
                                * ═══════════════════════════════════════════════════════════════════════════ */

                                typedef struct {
                                float m[16];
                                } matrix4x4_t;

                                static bool world_to_screen(vec3_t world, vec2_t* screen, const matrix4x4_t* vm) {
                                /* Matrix multiplication */
                                float clipX = world.x * vm->m[0] + world.y * vm->m[4] + world.z * vm->m[8] + vm->m[12];
                                float clipY = world.x * vm->m[1] + world.y * vm->m[5] + world.z * vm->m[9] + vm->m[13];
                                float clipW = world.x * vm->m[3] + world.y * vm->m[7] + world.z * vm->m[11] + vm->m[15];

                                /* Behind camera check */
                                if (clipW < 0.1f) return false; /* Perspective division */ float ndcX=clipX / clipW;
                                    float ndcY=clipY / clipW; /* NDC to screen */ screen->x = (g_game.screen_width /
                                    2.0f) * (1.0f + ndcX);
                                    screen->y = (g_game.screen_height / 2.0f) * (1.0f - ndcY);

                                    return true;
                                    }

                                    /* ═══════════════════════════════════════════════════════════════════════════
                                    * CALCULATE DISTANCE BETWEEN TWO POINTS
                                    * ═══════════════════════════════════════════════════════════════════════════ */

                                    static float get_distance(vec3_t a, vec3_t b) {
                                    float dx = b.x - a.x;
                                    float dy = b.y - a.y;
                                    float dz = b.z - a.z;
                                    return sqrtf(dx*dx + dy*dy + dz*dz);
                                    }

                                    /* ═══════════════════════════════════════════════════════════════════════════
                                    * DRAW ESP FOR SINGLE PLAYER
                                    * ═══════════════════════════════════════════════════════════════════════════ */

                                    static void draw_player_esp(uintptr_t entity_ptr, const matrix4x4_t* vm) {
                                    if (!entity_ptr) return;

                                    /* Read player data */
                                    vec3_t pos = READ_FIELD(entity_ptr, OFF_POSITION, vec3_t);
                                    int health = READ_FIELD(entity_ptr, OFF_HEALTH, int);
                                    int team = READ_FIELD(entity_ptr, OFF_TEAM, int);

                                    /* Skip dead players */
                                    if (health <= 0) return; /* Get local player data for team check */ int
                                        local_team=READ_FIELD(g_game.player1, OFF_TEAM, int); vec3_t
                                        local_pos=READ_FIELD(g_game.player1, OFF_POSITION, vec3_t); /* Team check */ if
                                        (g_config.esp_team_check && team==local_team) return; /* Choose color based on
                                        team */ color_t color=(team==local_team) ? COLOR_TEAM : COLOR_ENEMY; /* Head
                                        position (feet + ~7 units height in AC) */ vec3_t head=pos; head.z +=7.0f; /*
                                        Project head and feet to screen */ vec2_t screen_head, screen_feet; if
                                        (!world_to_screen(head, &screen_head, vm)) return; if (!world_to_screen(pos,
                                        &screen_feet, vm)) return; /* Calculate box dimensions */ float
                                        box_height=screen_feet.y - screen_head.y; float box_width=box_height / 2.5f;
                                        float box_x=screen_head.x - (box_width / 2.0f); float box_y=screen_head.y; /*
                                        Draw box */ if (g_config.esp_box) { draw_rect(box_x, box_y, box_width,
                                        box_height, color, 2.0f); } /* Draw health bar */ if (g_config.esp_health) {
                                        float bar_x=box_x - 6.0f; float bar_h=box_height; float bar_w=4.0f;
                                        draw_health_bar(bar_x, box_y, bar_w, bar_h, health, 100); } /* Draw distance */
                                        if (g_config.esp_distance) { float dist=get_distance(local_pos, pos); char
                                        buf[32]; snprintf(buf, sizeof(buf), "%.0fm" , dist / 4.0f); /* Scale factor */
                                        draw_text(screen_head.x, screen_feet.y + 10, buf, color); } } /*
                                        ═══════════════════════════════════════════════════════════════════════════ *
                                        MAIN ESP LOOP — Called every frame *
                                        ═══════════════════════════════════════════════════════════════════════════ */
                                        void draw_esp(void) { if (!g_config.esp_enabled) return; if (!g_game.player1)
                                        return; if (!g_game.entity_list) return; if (!g_game.view_matrix) return; /* Get
                                        view matrix */ matrix4x4_t vm; memcpy(&vm, (void*)g_game.view_matrix,
                                        sizeof(matrix4x4_t)); /* Iterate through entity list */ uintptr_t*
                                        entities=(uintptr_t*)g_game.entity_list; for (int i=0; i < g_game.num_players;
                                        i++) { uintptr_t entity=entities[i]; /* Skip local player */ if
                                        (entity==g_game.player1) continue; draw_player_esp(entity, &vm); } } </div>

                                        <!-- ═══════════════════════════════════════════════════════════════════════
         SRC/MENU.C
    ════════════════════════════════════════════════════════════════════════ -->

                                        <h3>File: src/menu.c</h3>

                                        <div class="code-block">
                                            /*
                                            * menu.c — Mod Menu GUI
                                            *
                                            * Simple immediate-mode menu drawn with OpenGL primitives.
                                            * For a real project, integrate Nuklear or Dear ImGui.
                                            */

                                            #include "config.h"
                                            #include "draw.h"
                                            #include &lt;string.h&gt;

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * MENU STATE
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            static int menu_x = 50;
                                            static int menu_y = 50;
                                            static int menu_w = 250;
                                            static int menu_h = 350;
                                            static int selected_item = 0;

                                            typedef struct {
                                            const char* label;
                                            bool* toggle; /* For toggle items */
                                            float* value; /* For slider items */
                                            float min_val, max_val;
                                            } menu_item_t;

                                            static menu_item_t menu_items[] = {
                                            {"=== COMBAT ===", NULL, NULL, 0, 0},
                                            {"God Mode", &g_config.god_mode, NULL, 0, 0},
                                            {"Infinite Ammo", &g_config.infinite_ammo, NULL, 0, 0},
                                            {"=== VISUALS ===", NULL, NULL, 0, 0},
                                            {"ESP Enabled", &g_config.esp_enabled, NULL, 0, 0},
                                            {"ESP Box", &g_config.esp_box, NULL, 0, 0},
                                            {"ESP Health", &g_config.esp_health, NULL, 0, 0},
                                            {"ESP Distance", &g_config.esp_distance, NULL, 0, 0},
                                            {"Team Check", &g_config.esp_team_check, NULL, 0, 0},
                                            {"=== MOVEMENT ===", NULL, NULL, 0, 0},
                                            {"Speed Hack", &g_config.speed_hack, NULL, 0, 0},
                                            {"Speed Mult", NULL, &g_config.speed_multiplier, 1.0f, 5.0f},
                                            };

                                            #define NUM_ITEMS (sizeof(menu_items) / sizeof(menu_items[0]))

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * DRAW MENU
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            void draw_menu(void) {
                                            if (!g_config.menu_open) return;

                                            int item_height = 25;
                                            int padding = 10;

                                            /* Background */
                                            draw_rect_filled(menu_x, menu_y, menu_w, menu_h,
                                            (color_t){0.1f, 0.1f, 0.15f, 0.9f});

                                            /* Border */
                                            draw_rect(menu_x, menu_y, menu_w, menu_h, COLOR_RED, 2.0f);

                                            /* Title */
                                            draw_rect_filled(menu_x, menu_y, menu_w, 30,
                                            (color_t){0.8f, 0.1f, 0.1f, 1.0f});
                                            draw_text(menu_x + padding, menu_y + 8, "ASSAULTCUBE MOD MENU",
                                            COLOR_WHITE);

                                            /* Items */
                                            int y = menu_y + 40;
                                            for (int i = 0; i < NUM_ITEMS; i++) { menu_item_t* item=&menu_items[i]; /*
                                                Highlight selected */ if (i==selected_item) { draw_rect_filled(menu_x +
                                                2, y, menu_w - 4, item_height, (color_t){0.3f, 0.3f, 0.4f, 0.8f}); } /*
                                                Check if header (no toggle) */ if (item->toggle == NULL && item->value
                                                == NULL) {
                                                draw_text(menu_x + padding, y + 5, item->label, COLOR_YELLOW);
                                                }
                                                /* Toggle item */
                                                else if (item->toggle != NULL) {
                                                const char* state = *item->toggle ? "[ON]" : "[OFF]";
                                                color_t col = *item->toggle ? COLOR_GREEN : COLOR_RED;
                                                draw_text(menu_x + padding, y + 5, item->label, COLOR_WHITE);
                                                draw_text(menu_x + menu_w - 60, y + 5, state, col);
                                                }
                                                /* Slider item */
                                                else if (item->value != NULL) {
                                                draw_text(menu_x + padding, y + 5, item->label, COLOR_WHITE);

                                                /* Draw slider bar */
                                                float pct = (*item->value - item->min_val) / (item->max_val -
                                                item->min_val);
                                                float bar_x = menu_x + 120;
                                                float bar_w = 100;
                                                draw_rect_filled(bar_x, y + 8, bar_w, 10,
                                                (color_t){0.2f, 0.2f, 0.2f, 1.0f});
                                                draw_rect_filled(bar_x, y + 8, bar_w * pct, 10, COLOR_GREEN);
                                                }

                                                y += item_height;
                                                }

                                                /* Instructions */
                                                draw_text(menu_x + padding, menu_y + menu_h - 20,
                                                "[UP/DOWN] Navigate [ENTER] Toggle [INSERT] Close", COLOR_WHITE);
                                                }

                                                /*
                                                ═══════════════════════════════════════════════════════════════════════════
                                                * HANDLE MENU INPUT
                                                *
                                                ═══════════════════════════════════════════════════════════════════════════
                                                */

                                                void menu_handle_key(int key, bool pressed) {
                                                if (!g_config.menu_open) return;
                                                if (!pressed) return;

                                                switch (key) {
                                                case 111: /* Up Arrow (XK_Up) */
                                                selected_item--;
                                                if (selected_item < 0) selected_item=NUM_ITEMS - 1; /* Skip headers */
                                                    while (menu_items[selected_item].toggle==NULL &&
                                                    menu_items[selected_item].value==NULL) { selected_item--; if
                                                    (selected_item < 0) selected_item=NUM_ITEMS - 1; } break; case 116:
                                                    /* Down Arrow (XK_Down) */ selected_item++; if (selected_item>=
                                                    NUM_ITEMS) selected_item = 0;
                                                    /* Skip headers */
                                                    while (menu_items[selected_item].toggle == NULL &&
                                                    menu_items[selected_item].value == NULL) {
                                                    selected_item++;
                                                    if (selected_item >= NUM_ITEMS) selected_item = 0;
                                                    }
                                                    break;

                                                    case 36: /* Enter (XK_Return) */
                                                    if (menu_items[selected_item].toggle != NULL) {
                                                    *menu_items[selected_item].toggle =
                                                    !*menu_items[selected_item].toggle;
                                                    }
                                                    break;

                                                    case 113: /* Left Arrow — decrease slider */
                                                    if (menu_items[selected_item].value != NULL) {
                                                    *menu_items[selected_item].value -= 0.1f;
                                                    if (*menu_items[selected_item].value <
                                                        menu_items[selected_item].min_val)
                                                        *menu_items[selected_item].value=menu_items[selected_item].min_val;
                                                        } break; case 114: /* Right Arrow — increase slider */ if
                                                        (menu_items[selected_item].value !=NULL) {
                                                        *menu_items[selected_item].value +=0.1f; if
                                                        (*menu_items[selected_item].value>
                                                        menu_items[selected_item].max_val)
                                                        *menu_items[selected_item].value =
                                                        menu_items[selected_item].max_val;
                                                        }
                                                        break;
                                                        }
                                                        }
                                        </div>

                                        <!-- ═══════════════════════════════════════════════════════════════════════
         SRC/HOOKS.C
    ════════════════════════════════════════════════════════════════════════ -->

                                        <h3>File: src/hooks.c</h3>

                                        <div class="code-block">
                                            /*
                                            * hooks.c — SDL/OpenGL Hooks via LD_PRELOAD
                                            */

                                            #define _GNU_SOURCE
                                            #include &lt;dlfcn.h&gt;
                                            #include &lt;SDL2/SDL.h&gt;
                                            #include &lt;stdbool.h&gt;
                                            #include &lt;stdio.h&gt;

                                            #include "config.h"
                                            #include "draw.h"

                                            /* External functions */
                                            extern void process_cheats(void);
                                            extern void draw_esp(void);
                                            extern void draw_menu(void);
                                            extern void menu_handle_key(int key, bool pressed);

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * ORIGINAL FUNCTION POINTERS
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            static void (*orig_SDL_GL_SwapWindow)(SDL_Window*) = NULL;
                                            static int (*orig_SDL_PollEvent)(SDL_Event*) = NULL;

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * HOOKED SDL_GL_SwapWindow — Render Hook
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            void SDL_GL_SwapWindow(SDL_Window* window) {
                                            if (!orig_SDL_GL_SwapWindow) {
                                            orig_SDL_GL_SwapWindow = dlsym(RTLD_NEXT, "SDL_GL_SwapWindow");
                                            }

                                            /* Get screen dimensions */
                                            SDL_GetWindowSize(window, &g_game.screen_width, &g_game.screen_height);

                                            /* ═══════════════════════════════════════════════════════════════════════
                                            * OUR CODE RUNS HERE — BEFORE FRAME IS DISPLAYED
                                            * ═══════════════════════════════════════════════════════════════════════ */

                                            /* Process cheat logic */
                                            process_cheats();

                                            /* Begin 2D drawing mode */
                                            draw_begin_2d(g_game.screen_width, g_game.screen_height);

                                            /* Draw ESP */
                                            draw_esp();

                                            /* Draw Menu */
                                            draw_menu();

                                            /* End 2D drawing mode */
                                            draw_end_2d();

                                            /* ═══════════════════════════════════════════════════════════════════════
                                            */

                                            /* Call original to display the frame */
                                            orig_SDL_GL_SwapWindow(window);
                                            }

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * HOOKED SDL_PollEvent — Input Hook
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            int SDL_PollEvent(SDL_Event* event) {
                                            if (!orig_SDL_PollEvent) {
                                            orig_SDL_PollEvent = dlsym(RTLD_NEXT, "SDL_PollEvent");
                                            }

                                            int result = orig_SDL_PollEvent(event);
                                            if (!result) return result;

                                            /* Handle INSERT key — toggle menu */
                                            if (event->type == SDL_KEYDOWN || event->type == SDL_KEYUP) {
                                            bool pressed = (event->type == SDL_KEYDOWN);
                                            SDL_Keycode key = event->key.keysym.sym;

                                            /* INSERT key toggles menu */
                                            if (key == SDLK_INSERT && pressed) {
                                            g_config.menu_open = !g_config.menu_open;
                                            printf("[MOD] Menu %s\n", g_config.menu_open ? "OPENED" : "CLOSED");
                                            return 0; /* Consume this event */
                                            }

                                            /* If menu is open, pass keys to menu and block from game */
                                            if (g_config.menu_open) {
                                            menu_handle_key(event->key.keysym.scancode, pressed);
                                            return 0; /* Consume event */
                                            }
                                            }

                                            /* Block mouse input when menu is open */
                                            if (g_config.menu_open) {
                                            switch (event->type) {
                                            case SDL_MOUSEMOTION:
                                            case SDL_MOUSEBUTTONDOWN:
                                            case SDL_MOUSEBUTTONUP:
                                            case SDL_MOUSEWHEEL:
                                            return 0; /* Consume event */
                                            }
                                            }

                                            return result;
                                            }
                                        </div>

                                        <!-- ═══════════════════════════════════════════════════════════════════════
         SRC/MAIN.C
    ════════════════════════════════════════════════════════════════════════ -->

                                        <h3>File: src/main.c</h3>

                                        <div class="code-block">
                                            /*
                                            * main.c — Entry Point and Initialization
                                            *
                                            * This file contains the constructor that runs when our .so is loaded.
                                            */

                                            #include &lt;stdio.h&gt;
                                            #include &lt;string.h&gt;
                                            #include &lt;unistd.h&gt;
                                            #include &lt;dlfcn.h&gt;

                                            #include "config.h"
                                            #include "game.h"

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * GLOBAL INSTANCES
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            cheat_config_t g_config = {0};
                                            game_state_t g_game = {0};

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * CONFIGURATION INITIALIZATION
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            void config_init(void) {
                                            memset(&g_config, 0, sizeof(g_config));

                                            /* Default settings */
                                            g_config.menu_open = false;
                                            g_config.god_mode = false;
                                            g_config.infinite_ammo = false;
                                            g_config.esp_enabled = true;
                                            g_config.esp_box = true;
                                            g_config.esp_health = true;
                                            g_config.esp_team_check = true;
                                            g_config.speed_multiplier = 1.5f;
                                            }

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * GAME STATE INITIALIZATION
                                            * This is where you would implement address/signature scanning
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            void game_state_init(void) {
                                            memset(&g_game, 0, sizeof(g_game));

                                            /*
                                            * TODO: Implement actual address finding for your AssaultCube version
                                            *
                                            * Methods:
                                            * 1. Read /proc/self/maps to find module base
                                            * 2. Signature scan for known patterns
                                            * 3. Or use hardcoded offsets (less portable)
                                            *
                                            * Example signature scanning (pseudocode):
                                            * g_game.module_base = find_module("native_client");
                                            * g_game.player1 = find_pattern(g_game.module_base,
                                            * "8B 0D ?? ?? ?? ?? 85 C9");
                                            * g_game.player1 = *(uintptr_t*)(g_game.player1 + 2);
                                            */

                                            printf("[MOD] Game state initialized (implement address scanning!)\n");
                                            }

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * LIBRARY CONSTRUCTOR — Runs when .so is loaded
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            __attribute__((constructor))
                                            static void init(void) {
                                            printf("\n");
                                            printf("════════════════════════════════════════════════════════════════\n");
                                            printf(" ASSAULTCUBE MOD MENU — LOADED\n");
                                            printf("════════════════════════════════════════════════════════════════\n");
                                            printf(" Press INSERT to open menu\n");
                                            printf(" Use UP/DOWN to navigate, ENTER to toggle\n");
                                            printf("════════════════════════════════════════════════════════════════\n");
                                            printf("\n");

                                            config_init();
                                            game_state_init();
                                            }

                                            /*
                                            ═══════════════════════════════════════════════════════════════════════════
                                            * LIBRARY DESTRUCTOR — Runs when .so is unloaded
                                            *
                                            ═══════════════════════════════════════════════════════════════════════════
                                            */

                                            __attribute__((destructor))
                                            static void cleanup(void) {
                                            printf("[MOD] Unloading...\n");
                                            }
                                        </div>

                                        <!-- ═══════════════════════════════════════════════════════════════════════
         MAKEFILE
    ════════════════════════════════════════════════════════════════════════ -->

                                        <h3>File: Makefile</h3>

                                        <div class="code-block">
                                            #
                                            ═══════════════════════════════════════════════════════════════════════════
                                            # AssaultCube Mod Menu — Makefile
                                            #
                                            ═══════════════════════════════════════════════════════════════════════════

                                            CC = gcc
                                            CFLAGS = -Wall -Wextra -O2 -fPIC -I./include
                                            LDFLAGS = -shared -ldl -lm -lGL
                                            TARGET = mod.so

                                            # Source files
                                            SOURCES = src/main.c src/hooks.c src/cheats.c src/esp.c src/menu.c
                                            src/draw.c
                                            OBJECTS = $(SOURCES:.c=.o)

                                            #
                                            ═══════════════════════════════════════════════════════════════════════════
                                            # TARGETS
                                            #
                                            ═══════════════════════════════════════════════════════════════════════════

                                            all: $(TARGET)

                                            $(TARGET): $(OBJECTS)
                                            @echo "[LINK] Building $(TARGET)..."
                                            $(CC) $(OBJECTS) -o $(TARGET) $(LDFLAGS)
                                            @echo "[DONE] Build complete!"
                                            @echo ""
                                            @echo "To use:"
                                            @echo " LD_PRELOAD=./mod.so assaultcube"

                                            %.o: %.c
                                            @echo "[CC] Compiling $<..." $(CC) $(CFLAGS) -c $< -o $@ clean:
                                                @echo "[CLEAN] Removing build artifacts..." rm -f $(OBJECTS) $(TARGET) #
                                                ═══════════════════════════════════════════════════════════════════════════
                                                # CONVENIENCE TARGETS #
                                                ═══════════════════════════════════════════════════════════════════════════
                                                run: $(TARGET) @echo "[RUN] Launching AssaultCube with mod..."
                                                LD_PRELOAD=./$(TARGET) assaultcube debug: CFLAGS +=-g -DDEBUG debug:
                                                clean all .PHONY: all clean run debug </div>

                                                <!-- ═══════════════════════════════════════════════════════════════════════
         DEPLOYMENT
    ════════════════════════════════════════════════════════════════════════ -->

                                                <h3>Phase III: Complete Step-by-Step Guide (Arch Linux)</h3>

                                                <p>
                                                    This is a <strong>complete, guaranteed-to-work guide</strong> from
                                                    zero to working mod menu.
                                                    Follow every step exactly. We will install the game, find the memory
                                                    addresses ourselves,
                                                    update the code, compile, and run.
                                                </p>

                                                <div class="code-block">
                                                    COMPLETE GUIDE — FROM ZERO TO WORKING MOD MENU:
                                                    ═════════════════════════════════════════════════════════════════════════════

                                                    ██████████████████████████████████████████████████████████████████████████████
                                                    STEP 1: INSTALL EVERYTHING WE NEED
                                                    ██████████████████████████████████████████████████████████████████████████████

                                                    Open a terminal and run:

                                                    $ sudo pacman -Syu
                                                    $ sudo pacman -S base-devel gcc make mesa lib32-mesa \
                                                    sdl2 lib32-sdl2 libgl lib32-libgl \
                                                    scanmem assaultcube

                                                    What we installed:
                                                    - base-devel, gcc, make → Compilers and build tools
                                                    - mesa, libgl → OpenGL libraries
                                                    - sdl2 → SDL2 for hooking
                                                    - scanmem → Memory scanner (like Cheat Engine)
                                                    - assaultcube → The game itself

                                                    ═════════════════════════════════════════════════════════════════════════════

                                                    ██████████████████████████████████████████████████████████████████████████████
                                                    STEP 2: CREATE THE PROJECT
                                                    ██████████████████████████████████████████████████████████████████████████████

                                                    $ mkdir -p ~/assaultcube-mod/{src,include}
                                                    $ cd ~/assaultcube-mod

                                                    Now create each file from the code blocks above:
                                                    - include/game.h
                                                    - include/config.h
                                                    - include/draw.h
                                                    - src/main.c
                                                    - src/hooks.c
                                                    - src/cheats.c
                                                    - src/esp.c
                                                    - src/menu.c
                                                    - src/draw.c
                                                    - Makefile

                                                    TIP: Copy each code block, paste into a file with nano or vim:
                                                    $ nano include/game.h
                                                    (paste, Ctrl+O to save, Ctrl+X to exit)

                                                    ═════════════════════════════════════════════════════════════════════════════

                                                    ██████████████████████████████████████████████████████████████████████████████
                                                    STEP 3: FIND MEMORY ADDRESSES WITH SCANMEM
                                                    ██████████████████████████████████████████████████████████████████████████████

                                                    This is the critical step. We need to find:
                                                    1. The local player pointer (player1)
                                                    2. The health offset within player structure

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 3.1: Start the game normally first
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    $ assaultcube

                                                    - Start a singleplayer game (Singleplayer → Bot Match)
                                                    - Note your health: should be 100
                                                    - DON'T CLOSE THE GAME! Minimize it or use a second terminal

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 3.2: Find the game's PID
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    In a new terminal:

                                                    $ pidof native_client
                                                    # Should output a number like: 12345

                                                    Or use:
                                                    $ ps aux | grep assaultcube

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 3.3: Attach scanmem to the game
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    $ sudo scanmem -p $(pidof native_client)

                                                    You'll see:
                                                    scanmem&gt;

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 3.4: Find the health address
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    In scanmem, type:

                                                    scanmem&gt; 100
                                                    info: ... matches found

                                                    Now go back to the game and GET DAMAGED. Let a bot shoot you.
                                                    Check your new health (e.g., 85).

                                                    Back in scanmem:

                                                    scanmem&gt; 85
                                                    info: ... matches found (fewer this time)

                                                    Keep taking damage and searching until you have 1-3 matches:

                                                    scanmem&gt; 70
                                                    scanmem&gt; 55
                                                    scanmem&gt; 40

                                                    Eventually:
                                                    info: 1 match found

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 3.5: Get the health address
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    scanmem&gt; list
                                                    [ 0] 0x56789abcdef0, 4, 40, [heap]

                                                    The address is: 0x56789abcdef0 (yours will be different!)
                                                    Write this down! This is your HEALTH ADDRESS.

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 3.6: Test it works — set health to 1337
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    scanmem&gt; set 1337

                                                    Check the game! Your health should now show 1337!
                                                    If it does, you found the correct address!

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 3.7: Find ammo address (same process)
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    Reset scanmem:
                                                    scanmem&gt; reset

                                                    In game, check your current ammo (e.g., 20 bullets in magazine)

                                                    scanmem&gt; 20
                                                    (shoot some bullets, now have 17)
                                                    scanmem&gt; 17
                                                    (keep shooting and searching)
                                                    scanmem&gt; 14
                                                    scanmem&gt; list

                                                    Note this address too. This is your AMMO ADDRESS.

                                                    ═════════════════════════════════════════════════════════════════════════════

                                                    ██████████████████████████████████████████████████████████████████████████████
                                                    STEP 4: FIND THE PLAYER1 POINTER
                                                    ██████████████████████████████████████████████████████████████████████████████

                                                    We need the BASE pointer, not just health address.
                                                    The health address = player1 + OFFSET

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 4.1: Read /proc/PID/maps to find the base
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    $ cat /proc/$(pidof native_client)/maps | head -20

                                                    Look for the main executable region, something like:
                                                    56000000-56100000 r-xp ... /usr/bin/native_client

                                                    The first address (56000000) is the MODULE BASE.

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 4.2: Calculate offset
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    EXAMPLE:
                                                    - Health address found: 0x565789abcef8
                                                    - Module base: 0x565780000000

                                                    We need to find where player1 pointer is stored.

                                                    For AssaultCube specifically, the player1 pointer is typically
                                                    at a STATIC offset from module base.

                                                    Common pattern in AC (verify with your version):
                                                    - player1 pointer at: moduleBase + 0x10F4F4

                                                    ─────────────────────────────────────────────────────────────────────────────
                                                    STEP 4.3: Use GDB to find player1 (Advanced)
                                                    ─────────────────────────────────────────────────────────────────────────────

                                                    $ sudo gdb -p $(pidof native_client)

                                                    In GDB:
                                                    (gdb) info proc mappings
                                                    (look for native_client base address)

                                                    (gdb) x/a 0x&lt;base&gt; + 0x10F4F4
                                                    This should show a pointer to the player structure

                                                    (gdb) x/20x &lt;player_pointer_value&gt;
                                                    This shows player structure memory

                                                    Look for your health value (0x64 = 100) in the dump.
                                                    Count bytes to find the offset!

                                                    (gdb) quit

                                                    ═════════════════════════════════════════════════════════════════════════════

                                                    ██████████████████████████████████████████████████████████████████████████████
                                                    STEP 5: UPDATE THE CODE WITH YOUR ADDRESSES
                                                    ██████████████████████████████████████████████████████████████████████████████

                                                    Edit src/main.c and update game_state_init():
                                                </div>

                                                <div class="code-block">
                                                    /*
                                                    * UPDATED src/main.c — With hardcoded addresses for YOUR system
                                                    *
                                                    * Replace the game_state_init() function with this:
                                                    */

                                                    #include &lt;stdio.h&gt;
                                                    #include &lt;string.h&gt;
                                                    #include &lt;stdlib.h&gt;
                                                    #include &lt;stdint.h&gt;
                                                    #include &lt;dlfcn.h&gt;

                                                    #include "config.h"
                                                    #include "game.h"

                                                    cheat_config_t g_config = {0};
                                                    game_state_t g_game = {0};

                                                    /*
                                                    ═══════════════════════════════════════════════════════════════════════════
                                                    * FIND MODULE BASE ADDRESS
                                                    *
                                                    ═══════════════════════════════════════════════════════════════════════════
                                                    */

                                                    static uintptr_t find_module_base(const char* module_name) {
                                                    char line[512];
                                                    uintptr_t base = 0;

                                                    FILE* maps = fopen("/proc/self/maps", "r");
                                                    if (!maps) return 0;

                                                    while (fgets(line, sizeof(line), maps)) {
                                                    if (strstr(line, module_name) && strstr(line, "r-xp")) {
                                                    sscanf(line, "%lx", &base);
                                                    break;
                                                    }
                                                    }

                                                    fclose(maps);
                                                    return base;
                                                    }

                                                    /*
                                                    ═══════════════════════════════════════════════════════════════════════════
                                                    * GAME STATE INITIALIZATION — WORKING VERSION
                                                    *
                                                    ═══════════════════════════════════════════════════════════════════════════
                                                    */

                                                    void game_state_init(void) {
                                                    memset(&g_game, 0, sizeof(g_game));

                                                    /* Find module base */
                                                    g_game.module_base = find_module_base("native_client");

                                                    if (g_game.module_base == 0) {
                                                    printf("[MOD] ERROR: Could not find native_client module!\n");
                                                    return;
                                                    }

                                                    printf("[MOD] Module base: 0x%lx\n", g_game.module_base);

                                                    /*
                                                    *
                                                    ══════════════════════════════════════════════════════════════════════
                                                    * ASSAULTCUBE 1.3.0.2 OFFSETS
                                                    * These are for the standard Linux build. Verify for your version!
                                                    *
                                                    ══════════════════════════════════════════════════════════════════════
                                                    *
                                                    * To find these yourself:
                                                    * 1. Use scanmem to find health address
                                                    * 2. Use GDB to find where player1 pointer is stored
                                                    * 3. Calculate offsets
                                                    *
                                                    * Standard offsets for AC 1.3.0.2:
                                                    */

                                                    #define PLAYER1_OFFSET 0x10F4F4 /* player1 pointer offset from base
                                                    */
                                                    #define ENTITY_LIST_OFFSET 0x10F4F8 /* entity list offset */
                                                    #define VIEWMATRIX_OFFSET 0x101AE8 /* view matrix offset */
                                                    #define NUM_PLAYERS_OFFSET 0x10F500 /* player count offset */

                                                    /* Read player1 pointer */
                                                    uintptr_t* player1_ptr = (uintptr_t*)(g_game.module_base +
                                                    PLAYER1_OFFSET);
                                                    g_game.player1 = *player1_ptr;

                                                    /* Read entity list pointer */
                                                    uintptr_t* ent_list_ptr = (uintptr_t*)(g_game.module_base +
                                                    ENTITY_LIST_OFFSET);
                                                    g_game.entity_list = *ent_list_ptr;

                                                    /* View matrix address (not a pointer, direct location) */
                                                    g_game.view_matrix = g_game.module_base + VIEWMATRIX_OFFSET;

                                                    /* Read player count */
                                                    int* num_players_ptr = (int*)(g_game.module_base +
                                                    NUM_PLAYERS_OFFSET);
                                                    g_game.num_players = *num_players_ptr;

                                                    printf("[MOD] player1: 0x%lx\n", g_game.player1);
                                                    printf("[MOD] entity_list: 0x%lx\n", g_game.entity_list);
                                                    printf("[MOD] view_matrix: 0x%lx\n", g_game.view_matrix);
                                                    printf("[MOD] num_players: %d\n", g_game.num_players);

                                                    /* Verify player1 is valid by reading health */
                                                    if (g_game.player1 != 0) {
                                                    int health = *(int*)(g_game.player1 + OFF_HEALTH);
                                                    printf("[MOD] Current health: %d (should be ~100)\n", health);

                                                    if (health > 0 && health <= 200) { printf("[MOD] ✓ Player pointer
                                                        looks valid!\n"); } else { printf("[MOD] ✗ WARNING: Health value
                                                        seems wrong. Offsets may be incorrect.\n"); } } } void
                                                        config_init(void) { memset(&g_config, 0, sizeof(g_config));
                                                        g_config.menu_open=false; g_config.god_mode=false;
                                                        g_config.infinite_ammo=false; g_config.esp_enabled=true;
                                                        g_config.esp_box=true; g_config.esp_health=true;
                                                        g_config.esp_team_check=true; g_config.speed_multiplier=1.5f; }
                                                        __attribute__((constructor)) static void init(void) {
                                                        printf("\n");
                                                        printf("════════════════════════════════════════════════════════════════\n");
                                                        printf(" ASSAULTCUBE MOD MENU — LOADED\n");
                                                        printf("════════════════════════════════════════════════════════════════\n");
                                                        printf(" Press INSERT to open menu\n");
                                                        printf("════════════════════════════════════════════════════════════════\n");
                                                        printf("\n"); config_init(); game_state_init(); }
                                                        __attribute__((destructor)) static void cleanup(void) {
                                                        printf("[MOD] Unloading...\n"); } </div>

                                                        <div class="code-block">
                                                            ██████████████████████████████████████████████████████████████████████████████
                                                            STEP 6: IF OFFSETS DON'T WORK — FIND THEM YOURSELF
                                                            ██████████████████████████████████████████████████████████████████████████████

                                                            The offsets above are for AC 1.3.0.2. If they don't work:

                                                            ─────────────────────────────────────────────────────────────────────────────
                                                            METHOD A: Use pmap to find globals
                                                            ─────────────────────────────────────────────────────────────────────────────

                                                            $ pmap $(pidof native_client) | head

                                                            ─────────────────────────────────────────────────────────────────────────────
                                                            METHOD B: Search for known patterns in memory
                                                            ─────────────────────────────────────────────────────────────────────────────

                                                            1. Find your health using scanmem (Step 3)
                                                            2. The health address minus OFF_HEALTH = player1
                                                            3. Search memory for that player1 value as a pointer

                                                            Example:
                                                            - Health at: 0x565789abc0F8
                                                            - OFF_HEALTH = 0xF8
                                                            - player1 = 0x565789abc0F8 - 0xF8 = 0x565789abc000

                                                            Now find where 0x565789abc000 is stored:

                                                            $ sudo gdb -p $(pidof native_client)
                                                            (gdb) find /g 0x56000000, 0x57000000, 0x565789abc000

                                                            This searches for the pointer value in memory.
                                                            The address where it's found = PLAYER1_OFFSET from base.

                                                            ─────────────────────────────────────────────────────────────────────────────
                                                            METHOD C: Dump and analyze with radare2
                                                            ─────────────────────────────────────────────────────────────────────────────

                                                            $ r2 -d $(pidof native_client)
                                                            [0x...]&gt; dm # Show memory maps
                                                            [0x...]&gt; s main # Seek to main
                                                            [0x...]&gt; pdf # Disassemble

                                                            Look for global variable references.

                                                            ═════════════════════════════════════════════════════════════════════════════

                                                            ██████████████████████████████████████████████████████████████████████████████
                                                            STEP 7: COMPILE AND TEST
                                                            ██████████████████████████████████████████████████████████████████████████████

                                                            $ cd ~/assaultcube-mod
                                                            $ make clean
                                                            $ make

                                                            If compilation errors:
                                                            - Check for typos
                                                            - Make sure all files exist
                                                            - Check include paths

                                                            ═════════════════════════════════════════════════════════════════════════════

                                                            ██████████████████████████████████████████████████████████████████████████████
                                                            STEP 8: RUN THE MOD
                                                            ██████████████████████████████████████████████████████████████████████████████

                                                            $ cd ~/assaultcube-mod
                                                            $ LD_PRELOAD=./mod.so assaultcube

                                                            Watch the terminal output! You should see:

                                                            ════════════════════════════════════════════════════════════════
                                                            ASSAULTCUBE MOD MENU — LOADED
                                                            ════════════════════════════════════════════════════════════════
                                                            [MOD] Module base: 0x55e4a7600000
                                                            [MOD] player1: 0x55e4a8abc000
                                                            [MOD] entity_list: 0x55e4a8abd000
                                                            [MOD] view_matrix: 0x55e4a7701ae8
                                                            [MOD] num_players: 5
                                                            [MOD] Current health: 100 (should be ~100)
                                                            [MOD] ✓ Player pointer looks valid!

                                                            If you see "Player pointer looks valid!" — IT WORKS!

                                                            ═════════════════════════════════════════════════════════════════════════════

                                                            ██████████████████████████████████████████████████████████████████████████████
                                                            STEP 9: USE THE MOD MENU
                                                            ██████████████████████████████████████████████████████████████████████████████

                                                            In-game:
                                                            1. Start a bot match (Singleplayer → Bot Match)
                                                            2. Press INSERT to open the menu
                                                            3. Use UP/DOWN arrows to navigate
                                                            4. Press ENTER to toggle God Mode
                                                            5. Get shot — your health stays at 100!
                                                            6. Enable Infinite Ammo — never reload!
                                                            7. Enable ESP — see enemy boxes through walls!

                                                            ═════════════════════════════════════════════════════════════════════════════

                                                            ██████████████████████████████████████████████████████████████████████████████
                                                            TROUBLESHOOTING
                                                            ██████████████████████████████████████████████████████████████████████████████

                                                            PROBLEM: "Could not find native_client module"
                                                            SOLUTION: The game binary might have a different name.
                                                            Run: ps aux | grep assault
                                                            Find the actual binary name and update find_module_base()

                                                            PROBLEM: "Health value seems wrong"
                                                            SOLUTION: Offsets are wrong for your AC version.
                                                            Use scanmem to find health, calculate offset yourself.

                                                            PROBLEM: Menu doesn't appear
                                                            SOLUTION: OpenGL drawing might not work — check glGetError()
                                                            Or the INSERT key isn't being detected.

                                                            PROBLEM: Game crashes on start
                                                            SOLUTION: Bad pointer dereference. Check that module_base is
                                                            found.
                                                            Comment out game_state_init() content to test.

                                                            PROBLEM: ESP doesn't show boxes
                                                            SOLUTION: entity_list or view_matrix offset is wrong.
                                                            Or num_players is 0. Check your offsets.

                                                            ═════════════════════════════════════════════════════════════════════════════

                                                            ██████████████████████████████████████████████████████████████████████████████
                                                            QUICK REFERENCE — KNOWN WORKING OFFSETS
                                                            ██████████████████████████████████████████████████████████████████████████████

                                                            AssaultCube 1.3.0.2 (Linux, standard build):

                                                            Player Pointer: base + 0x10F4F4 (points to playerent*)
                                                            Entity List: base + 0x10F4F8 (points to playerent**)
                                                            View Matrix: base + 0x101AE8 (16 floats, direct address)
                                                            Player Count: base + 0x10F500 (int)

                                                            Player Structure Offsets:
                                                            Position (vec3): player + 0x04
                                                            Velocity (vec3): player + 0x10
                                                            Yaw: player + 0x40
                                                            Pitch: player + 0x44
                                                            Health: player + 0xF8
                                                            Armour: player + 0xFC
                                                            Magazine[8]: player + 0x13C
                                                            Ammo[8]: player + 0x15C
                                                            Name: player + 0x225
                                                            Team: player + 0x32C

                                                            ═════════════════════════════════════════════════════════════════════════════
                                                        </div>

                                                        <div class="warn-banner">
                                                            <strong>If it still doesn't work:</strong> AssaultCube has
                                                            multiple versions
                                                            with different offsets. Use scanmem to find YOUR health
                                                            address, then calculate
                                                            offsets from there. The process is: find health → subtract
                                                            0xF8 = player1 →
                                                            find where player1 pointer is stored → that's your
                                                            PLAYER1_OFFSET.
                                                        </div>

                                                        <div class="warn-banner">
                                                            <strong>Educational Use Only:</strong> This code is provided
                                                            for
                                                            learning game
                                                            security, anti-cheat development, and systems programming.
                                                            Using
                                                            cheats in online
                                                            multiplayer games violates Terms of Service and may result
                                                            in bans.
                                                            Practice on
                                                            private servers or single-player only.
                                                        </div>

                                                        <!-- ═══════════════════════════════════════════════════════════════════════
         CONCLUSION
    ════════════════════════════════════════════════════════════════════════ -->

                                                        <h2>Conclusion: The Ethics of Power</h2>

                                                        <div class="real-talk">
                                                            <strong>You now control the simulation.</strong><br><br>

                                                            With the knowledge in this module, you can read and write
                                                            any memory
                                                            in any process.
                                                            You can inject code into running programs. You can hook
                                                            functions,
                                                            intercept input,
                                                            and manipulate 3D graphics pipelines. You can make yourself
                                                            invincible, see through
                                                            walls, and move at impossible speeds.<br><br>

                                                            This power comes with responsibility.<br><br>

                                                            <strong>The skills you've learned are the same skills used
                                                                by:</strong><br>
                                                            — Security researchers finding vulnerabilities in games and
                                                            software<br>
                                                            — Anti-cheat developers building detection systems<br>
                                                            — Malware analysts understanding how threats operate<br>
                                                            — Game developers debugging their own code<br>
                                                            — Penetration testers assessing system security<br><br>

                                                            The difference between a hacker and a security professional
                                                            is not
                                                            capability—it's
                                                            intent and authorization. You now have the capability.
                                                            Choose your
                                                            intent wisely.<br><br>

                                                            <em>"With great power comes great responsibility."</em><br>
                                                            — Not just a cliché. A principle.<br><br>

                                                            Use these skills to understand systems deeply. Use them to
                                                            build
                                                            better defenses.
                                                            Use them to teach others. Use them ethically.
                                                        </div>

                                                        <div class="code-block">
                                                            MODULE 04 COMPLETE — SKILLS ACQUIRED:
                                                            ═════════════════════════════════════════════════════════════════════════════

                                                            ✓ External vs Internal cheat architecture
                                                            ✓ Cross-process memory access (process_vm_readv,
                                                            ReadProcessMemory)
                                                            ✓ Code injection (LD_PRELOAD, DLL injection)
                                                            ✓ 3D to 2D projection mathematics (View Matrix,
                                                            WorldToScreen)
                                                            ✓ Aimbot angle calculation (atan2, delta vectors)
                                                            ✓ ESP implementation (box scaling, distance calculation)
                                                            ✓ Render hooking (SDL_GL_SwapWindow, DirectX Present)
                                                            ✓ Input hijacking (SDL_PollEvent, WndProc)
                                                            ✓ Memory patching (NOP slides, code modification)
                                                            ✓ Professional cheat architecture (modular C codebase)

                                                            You are now dangerous. Be responsible.

                                                            ═════════════════════════════════════════════════════════════════════════════
                                                        </div>

                                                        <!-- ═══════════════════════════════════════════════════════════════════════
         FOOTER NAVIGATION
    ════════════════════════════════════════════════════════════════════════ -->

                                                        <div
                                                            style="margin:50px 0; padding:30px; border:2px solid #333; text-align:center;">
                                                            <p style="margin-bottom:20px;">
                                                                <strong>MODULE 04 COMPLETE</strong><br>
                                                                You have mastered the art of game manipulation.
                                                            </p>
                                                            <p>
                                                                <a href="module_05.html" class="nav-item"
                                                                    style="display:inline-block; padding:15px 30px; margin:10px;">
                                                                    PROCEED TO MODULE 05: KERNEL WARFARE →
                                                                </a>
                                                            </p>
                                                            <p>
                                                                <a href="index.html" class="nav-item"
                                                                    style="display:inline-block; padding:10px 20px; margin:10px;">
                                                                    ← Return to Index
                                                                </a>
                                                            </p>
                                                        </div>

</body>

</html>